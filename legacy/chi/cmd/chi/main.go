// Code generated by connectorgen - Edit as necessary.

package main

import (
	"context"
	"net/http"

	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/heptiolabs/healthcheck"
	"github.com/rs/zerolog/log"

	"blep.ai/data/chain/ethereum/ethclient"
	"blep.ai/data/config"
	"blep.ai/data/connectors/source/chi"
	"blep.ai/data/monitor"
	"github.com/nakji-network/connector/kafkautils"
)

var conf = config.InitConfig()

func init() {
	kafkautils.TopicTypeRegistry.Load(chi.TopicTypes)
	conf.SetDefault("chi.kafka.topic.chi_approval", ".fct.nakji.chi.0_0_0.chi_approval")
	conf.SetDefault("chi.kafka.topic.chi_transfer", ".fct.nakji.chi.0_0_0.chi_transfer")

	conf.SetDefault("chi.kafka.txID", "chi")

	conf.SetDefault("chi.chiAddress", "0x0000000000004946c0e9F43F4Dee607b0eF1fA1c")
}

func main() {
	kp, err := kafkautils.NewProducer(conf.GetString("kafka.url"), conf.GetString("chi.kafka.txID"))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to create new kafka producer")
	}

	urls := conf.GetStringSlice("ethereum.rpc")

	log.Info().Strs("url", urls).Msg("connecting to Ethereum RPC")
	ethClientPool, err := ethclient.DialPoolContext(context.Background(), urls)
	if err != nil {
		log.Fatal().Err(err).Msg("Ethereum RPC connection error")
	}

	// For Liveness and Readiness Probe checks
	health := healthcheck.NewHandler()
	go http.ListenAndServe("0.0.0.0:8080", health)
	log.Info().Str("addr", "0.0.0.0:8080").Msg("healthcheck listening on /live and /ready")
	chiAddress := ethcommon.HexToAddress(conf.GetString("chi.chiAddress"))

	addresses := map[string][]ethcommon.Address{
		"chi": {chiAddress},
	}

	topics := map[string]kafkautils.Topic{
		"chi_approval": kafkautils.MustParseTopic(conf.GetString("chi.kafka.topic.chi_approval"), conf.GetString("kafka.env")),
		"chi_transfer": kafkautils.MustParseTopic(conf.GetString("chi.kafka.topic.chi_transfer"), conf.GetString("kafka.env")),
	}

	connector := chi.NewConnector(
		kp,
		addresses,
		topics,
		ethClientPool,
	)

	monitor.StartMonitor("chi")
	connector.Start(context.Background(), conf.GetUint64("chi.backfillNumBlocks"))
}
