// Code generated by connectorgen - Edit as necessary.
package traderjoe

import (
	"context"
	"fmt"
	"math/big"
	"runtime"
	"strings"
	"sync"
	"time"

	"blep.ai/data/chain/avalanche/avaxclient"
	"blep.ai/data/common"
	"blep.ai/data/connectors/source/traderjoe/joebar"
	"blep.ai/data/connectors/source/traderjoe/joefactory"
	"blep.ai/data/connectors/source/traderjoe/joehattoken"
	"blep.ai/data/connectors/source/traderjoe/joepair"
	"blep.ai/data/connectors/source/traderjoe/joetoken"
	"blep.ai/data/connectors/source/traderjoe/joetroller"
	"blep.ai/data/connectors/source/traderjoe/masterchefjoev2"
	"blep.ai/data/connectors/source/traderjoe/masterchefjoev3"
	"blep.ai/data/database"
	"blep.ai/data/tokencache"
	"github.com/nakji-network/connector/kafkautils"

	sq "github.com/Masterminds/squirrel"
	"github.com/ava-labs/coreth/accounts/abi"
	"github.com/ava-labs/coreth/core/types"
	"github.com/ava-labs/coreth/interfaces"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/rs/zerolog/log"
	"golang.org/x/sync/semaphore"
	"google.golang.org/protobuf/types/known/timestamppb"
)

const (
	Namespace      = "traderjoe"
	TokenNamespace = "avalanche"
)

type Connector struct {
	KP             kafkautils.ProducerInterface
	Topics         map[string]kafkautils.Topic
	AvaxClientPool avaxclient.ETHClientPool
	addresses      map[string][]ethcommon.Address
	blockCache     map[uint64]uint64
	tokenCache     tokencache.TokenCacheInterface
	Db             *database.Database
}

func NewConnector(kp kafkautils.ProducerInterface, addresses map[string][]ethcommon.Address, topics map[string]kafkautils.Topic, avaxClientPool avaxclient.ETHClientPool, db *database.Database, tokenCache tokencache.TokenCacheInterface) *Connector {
	var blockCache map[uint64]uint64

	return &Connector{
		KP:             kp,
		Topics:         topics,
		AvaxClientPool: avaxClientPool,
		addresses:      addresses,
		tokenCache:     tokenCache,
		blockCache:     blockCache,
		Db:             db,
	}
}

func (c *Connector) Start(ctx context.Context, backfillNumBlocks uint64) {
	c.InsertPairAddresses()
	// Mainly serves as Keepalive for websocket connection to RPC endpoint by subscribing to new heads
	unsubscribe := make(chan interface{})
	headers := c.AvaxClientPool.ConsumeHeaders(unsubscribe)

	joeBarLogs := make(chan types.Log)
	joeBarErrChan := c.startListener(ctx, "joebar", joeBarLogs)

	joeFactoryLogs := make(chan types.Log)
	factoryErrChan := c.startListener(ctx, "joefactory", joeFactoryLogs)

	joePairLogs := make(chan types.Log)
	pairErrChan := c.startListener(ctx, "joepair", joePairLogs)

	joeHatTokenLogs := make(chan types.Log)
	joeHatTokenErrChan := c.startListener(ctx, "joehattoken", joeHatTokenLogs)

	joeTokenLogs := make(chan types.Log)
	joeTokenLogsErrChan := c.startListener(ctx, "joetoken", joeTokenLogs)

	joeTrollerLogs := make(chan types.Log)
	joeTrollerLogsErrChan := c.startListener(ctx, "joetroller", joeTrollerLogs)

	masterChefJoeV2Logs := make(chan types.Log)
	masterChefJoeV2LogsErrChan := c.startListener(ctx, "masterchefjoev2", masterChefJoeV2Logs)

	masterChefJoeV3Logs := make(chan types.Log)
	masterChefJoeV3LogsErrChan := c.startListener(ctx, "masterchefjoev3", masterChefJoeV3Logs)

	sink := make(chan *kafkautils.Message, 10000)
	errorSubs := []<-chan error{joeBarErrChan, factoryErrChan, pairErrChan, joeHatTokenErrChan, joeTokenLogsErrChan, joeTrollerLogsErrChan, masterChefJoeV2LogsErrChan, masterChefJoeV3LogsErrChan}
	out := common.MergeErrChans(errorSubs...)

	err := c.KP.EnableTransactions()
	if err != nil {
		log.Fatal().Err(err).Msg("Transaction was not enabled")
	}
	go c.KP.WriteAndCommitSink(sink)

	var once1 sync.Once
	var once2 sync.Once
	var once3 sync.Once
	var once4 sync.Once
	var once5 sync.Once
	var once6 sync.Once
	var once7 sync.Once

	for {
		select {
		case <-ctx.Done():
			log.Info().Msg("worker cancelled and shutting down")
			return
		case header := <-headers:
			log.Debug().
				Str("block", header.Number.String()).
				Uint64("ts", header.Time).
				Msg("header received")

			avaxclient.CacheBlockTimestamp(header.Hash(), header.Time)
		case err = <-out:
			log.Error().Err(err).Msg("sub error")
			return
		case evLog := <-joeBarLogs:
			if evLog.Removed {
				continue
			}

			go once1.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "joebar", c.JoeBarLogToMsg)
			})

			msg := c.JoeBarLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-joeFactoryLogs:
			if evLog.Removed {
				continue
			}

			msg := c.JoeFactoryLogToMsg(evLog, errorSubs, joePairLogs)
			if msg != nil {
				sink <- msg
			}
		case evLog := <-joeHatTokenLogs:
			if evLog.Removed {
				continue
			}

			go once2.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "joehattoken", c.JoeHatTokenLogToMsg)
			})

			msg := c.JoeHatTokenLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-joePairLogs:
			if evLog.Removed {
				continue
			}

			go once3.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "joepair", c.JoePairLogToMsg)
			})

			msg := c.JoePairLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-joeTokenLogs:
			if evLog.Removed {
				continue
			}

			go once4.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "joetoken", c.JoeTokenLogToMsg)
			})

			msg := c.JoeTokenLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-joeTrollerLogs:
			if evLog.Removed {
				continue
			}

			go once5.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "joetroller", c.JoeTrollerLogToMsg)
			})

			msg := c.JoeTrollerLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-masterChefJoeV2Logs:
			if evLog.Removed {
				continue
			}

			go once6.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "masterchefjoev2", c.MasterChefJoeV2LogToMsg)
			})

			msg := c.MasterChefJoeV2LogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-masterChefJoeV3Logs:
			if evLog.Removed {
				continue
			}

			go once7.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "masterchefjoev3", c.MasterChefJoeV3LogToMsg)
			})

			msg := c.MasterChefJoeV3LogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		}
	}
}

func (c *Connector) startListener(ctx context.Context, contractName string, logCh chan types.Log) <-chan error {
	query := interfaces.FilterQuery{
		Addresses: c.addresses[contractName],
	}

	errCh, err := c.AvaxClientPool.ChunkedSubscribeFilterLogs(ctx, query, logCh, 0)
	if err != nil {
		msg := fmt.Sprintf("%s contract listener failed", contractName)
		log.Fatal().Err(err).
			Interface("query", query).
			Msg(msg)
	}
	msg := fmt.Sprintf("%s contract listener live", contractName)
	log.Info().Interface("query", query).Msg(msg)

	return errCh
}

func (c *Connector) JoeBarLogToMsg(evLog types.Log) *kafkautils.Message {
	ts, err := c.AvaxClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	joebarAbi, err := abi.JSON(strings.NewReader(joebar.JoebarABI))
	if err != nil {
		log.Error().Err(err).Msg("Failed to read Joebar ABI")
		return nil
	}

	ev, err := joebarAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msg("Failed to find event")
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Approval":
		event := new(joebar.JoebarApproval)
		if err := avaxclient.UnpackLog(joebarAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joebar_approval"],
			Key:   kafkautils.NewKey(Namespace, "Approval"),
			ProtoMsg: &joebar.Approval{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:   event.Owner.Bytes(),
				Spender: event.Spender.Bytes(),
				Value:   event.Value.Bytes(),
			},
		}
	case "Transfer":
		event := new(joebar.JoebarTransfer)
		if err := avaxclient.UnpackLog(joebarAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joebar_transfer"],
			Key:   kafkautils.NewKey(Namespace, "Transfer"),
			ProtoMsg: &joebar.Transfer{
				Ts:    common.UnixToTimestampPb(int64(ts * 1000)),
				From:  event.From.Bytes(),
				To:    event.To.Bytes(),
				Value: event.Value.Bytes(),
			},
		}
	}

	return nil
}

func (c *Connector) JoeFactoryLogToMsg(evLog types.Log, errorSubs []<-chan error, joepairLogs chan types.Log) *kafkautils.Message {
	ts, err := c.AvaxClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	joefactoryAbi, err := abi.JSON(strings.NewReader(joefactory.JoefactoryABI))
	if err != nil {
		log.Error().Err(err).Msg("Failed to read Joefactory ABI")
		return nil
	}

	ev, err := joefactoryAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msg("Failed to find event")
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "PairCreated":
		event := new(joefactory.JoefactoryPairCreated)
		if err := avaxclient.UnpackLog(joefactoryAbi, event, "PairCreated", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}
		c.InsertPairAddress(event)
		query := interfaces.FilterQuery{
			Addresses: []ethcommon.Address{event.Pair},
		}
		sub, err := c.AvaxClientPool.SubscribeFilterLogs(context.Background(), query, joepairLogs)
		if err != nil {
			log.Fatal().Err(err).
				Interface("query", query).
				Msg("Subscribe joepair failed to subscribe")
		}

		errorSubs = append(errorSubs, sub.Err())

		return &kafkautils.Message{
			Topic: c.Topics["joefactory_paircreated"],
			Key:   kafkautils.NewKey(Namespace, "PairCreated"),
			ProtoMsg: &joefactory.PairCreated{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				Token0: event.Token0.Bytes(),
				Token1: event.Token1.Bytes(),
				Pair:   event.Pair.Bytes(),
				Arg3:   event.Arg3.Bytes(),
			},
		}
	}

	return nil
}

func (c *Connector) JoeHatTokenLogToMsg(evLog types.Log) *kafkautils.Message {
	ts, err := c.AvaxClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	joehattokenAbi, err := abi.JSON(strings.NewReader(joehattoken.JoehattokenABI))
	if err != nil {
		log.Error().Err(err).Msg("Failed to read Joehattoken ABI")
		return nil
	}

	ev, err := joehattokenAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msg("Failed to find event")
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Approval":
		event := new(joehattoken.JoehattokenApproval)
		if err := avaxclient.UnpackLog(joehattokenAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joehattoken_approval"],
			Key:   kafkautils.NewKey(Namespace, "Approval"),
			ProtoMsg: &joehattoken.Approval{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:   event.Owner.Bytes(),
				Spender: event.Spender.Bytes(),
				Value:   event.Value.Bytes(),
			},
		}
	case "Transfer":
		event := new(joehattoken.JoehattokenTransfer)
		if err := avaxclient.UnpackLog(joehattokenAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joehattoken_transfer"],
			Key:   kafkautils.NewKey(Namespace, "Transfer"),
			ProtoMsg: &joehattoken.Transfer{
				Ts:    common.UnixToTimestampPb(int64(ts * 1000)),
				From:  event.From.Bytes(),
				To:    event.To.Bytes(),
				Value: event.Value.Bytes(),
			},
		}
	}

	return nil
}

func (c *Connector) JoePairLogToMsg(evLog types.Log) *kafkautils.Message {
	ts, err := c.AvaxClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	joepairAbi, err := abi.JSON(strings.NewReader(joepair.JoePairMetaData.ABI))
	if err != nil {
		log.Error().Err(err).Msg("Failed to read Joepair ABI")
		return nil
	}

	ev, err := joepairAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msgf("Failed to find event, %v", evLog.Topics[0].String())
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Approval":
		event := new(joepair.JoePairApproval)
		if err := avaxclient.UnpackLog(joepairAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joepair_approval"],
			Key:   kafkautils.NewKey(Namespace, "Approval"),
			ProtoMsg: &joepair.Approval{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:   event.Owner.Bytes(),
				Spender: event.Spender.Bytes(),
				Value:   event.Value.Bytes(),
			},
		}
	case "Burn":
		event := new(joepair.JoePairBurn)
		if err := avaxclient.UnpackLog(joepairAbi, event, "Burn", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joepair_burn"],
			Key:   kafkautils.NewKey(Namespace, "Burn"),
			ProtoMsg: &joepair.Burn{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Sender:  event.Sender.Bytes(),
				Amount0: event.Amount0.Bytes(),
				Amount1: event.Amount1.Bytes(),
				To:      event.To.Bytes(),
			},
		}
	case "Mint":
		event := new(joepair.JoePairMint)
		if err := avaxclient.UnpackLog(joepairAbi, event, "Mint", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joepair_mint"],
			Key:   kafkautils.NewKey(Namespace, "Mint"),
			ProtoMsg: &joepair.Mint{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Sender:  event.Sender.Bytes(),
				Amount0: event.Amount0.Bytes(),
				Amount1: event.Amount1.Bytes(),
			},
		}
	case "Swap":
		event := new(joepair.JoePairSwap)
		if err := avaxclient.UnpackLog(joepairAbi, event, "Swap", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joepair_swap"],
			Key:   kafkautils.NewKey(Namespace, "Swap"),
			ProtoMsg: &joepair.Swap{
				Ts:         common.UnixToTimestampPb(int64(ts * 1000)),
				Sender:     event.Sender.Bytes(),
				Amount0In:  event.Amount0In.Bytes(),
				Amount1In:  event.Amount1In.Bytes(),
				Amount0Out: event.Amount0Out.Bytes(),
				Amount1Out: event.Amount1Out.Bytes(),
				To:         event.To.Bytes(),
			},
		}
	case "Sync":
		event := new(joepair.JoePairSync)
		if err := avaxclient.UnpackLog(joepairAbi, event, "Sync", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joepair_sync"],
			Key:   kafkautils.NewKey(Namespace, "Sync"),
			ProtoMsg: &joepair.Sync{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				Reserve0: event.Reserve0.Bytes(),
				Reserve1: event.Reserve1.Bytes(),
			},
		}
	case "Transfer":
		event := new(joepair.JoePairTransfer)
		if err := avaxclient.UnpackLog(joepairAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joepair_transfer"],
			Key:   kafkautils.NewKey(Namespace, "Transfer"),
			ProtoMsg: &joepair.Transfer{
				Ts:    common.UnixToTimestampPb(int64(ts * 1000)),
				From:  event.From.Bytes(),
				To:    event.To.Bytes(),
				Value: event.Value.Bytes(),
			},
		}
	}

	return nil
}

func (c *Connector) JoeTokenLogToMsg(evLog types.Log) *kafkautils.Message {
	ts, err := c.AvaxClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	joetokenAbi, err := abi.JSON(strings.NewReader(joetoken.JoetokenABI))
	if err != nil {
		log.Error().Err(err).Msg("Failed to read Joetoken ABI")
		return nil
	}

	ev, err := joetokenAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msg("Failed to find event")
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Approval":
		event := new(joetoken.JoetokenApproval)
		if err := avaxclient.UnpackLog(joetokenAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetoken_approval"],
			Key:   kafkautils.NewKey(Namespace, "Approval"),
			ProtoMsg: &joetoken.Approval{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:   event.Owner.Bytes(),
				Spender: event.Spender.Bytes(),
				Value:   event.Value.Bytes(),
			},
		}
	case "DelegateChanged":
		event := new(joetoken.JoetokenDelegateChanged)
		if err := avaxclient.UnpackLog(joetokenAbi, event, "DelegateChanged", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetoken_delegatechanged"],
			Key:   kafkautils.NewKey(Namespace, "DelegateChanged"),
			ProtoMsg: &joetoken.DelegateChanged{
				Ts:           common.UnixToTimestampPb(int64(ts * 1000)),
				Delegator:    event.Delegator.Bytes(),
				FromDelegate: event.FromDelegate.Bytes(),
				ToDelegate:   event.ToDelegate.Bytes(),
			},
		}
	case "DelegateVotesChanged":
		event := new(joetoken.JoetokenDelegateVotesChanged)
		if err := avaxclient.UnpackLog(joetokenAbi, event, "DelegateVotesChanged", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetoken_delegatevoteschanged"],
			Key:   kafkautils.NewKey(Namespace, "DelegateVotesChanged"),
			ProtoMsg: &joetoken.DelegateVotesChanged{
				Ts:              common.UnixToTimestampPb(int64(ts * 1000)),
				Delegate:        event.Delegate.Bytes(),
				PreviousBalance: event.PreviousBalance.Bytes(),
				NewBalance:      event.NewBalance.Bytes(),
			},
		}
	case "OwnershipTransferred":
		event := new(joetoken.JoetokenOwnershipTransferred)
		if err := avaxclient.UnpackLog(joetokenAbi, event, "OwnershipTransferred", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetoken_ownershiptransferred"],
			Key:   kafkautils.NewKey(Namespace, "OwnershipTransferred"),
			ProtoMsg: &joetoken.OwnershipTransferred{
				Ts:            common.UnixToTimestampPb(int64(ts * 1000)),
				PreviousOwner: event.PreviousOwner.Bytes(),
				NewOwner:      event.NewOwner.Bytes(),
			},
		}
	case "Transfer":
		event := new(joetoken.JoetokenTransfer)
		if err := avaxclient.UnpackLog(joetokenAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetoken_transfer"],
			Key:   kafkautils.NewKey(Namespace, "Transfer"),
			ProtoMsg: &joetoken.Transfer{
				Ts:    common.UnixToTimestampPb(int64(ts * 1000)),
				From:  event.From.Bytes(),
				To:    event.To.Bytes(),
				Value: event.Value.Bytes(),
			},
		}
	}

	return nil
}

func (c *Connector) JoeTrollerLogToMsg(evLog types.Log) *kafkautils.Message {
	ts, err := c.AvaxClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	joetrollerAbi, err := abi.JSON(strings.NewReader(joetroller.JoetrollerABI))
	if err != nil {
		log.Error().Err(err).Msg("Failed to read Joetroller ABI")
		return nil
	}

	ev, err := joetrollerAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msg("Failed to find event")
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Failure":
		event := new(joetroller.JoetrollerFailure)
		if err := avaxclient.UnpackLog(joetrollerAbi, event, "Failure", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetroller_failure"],
			Key:   kafkautils.NewKey(Namespace, "Failure"),
			ProtoMsg: &joetroller.Failure{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				Error:  event.Error.Bytes(),
				Info:   event.Info.Bytes(),
				Detail: event.Detail.Bytes(),
			},
		}
	case "NewAdmin":
		event := new(joetroller.JoetrollerNewAdmin)
		if err := avaxclient.UnpackLog(joetrollerAbi, event, "NewAdmin", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetroller_newadmin"],
			Key:   kafkautils.NewKey(Namespace, "NewAdmin"),
			ProtoMsg: &joetroller.NewAdmin{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldAdmin: event.OldAdmin.Bytes(),
				NewAdmin: event.NewAdmin.Bytes(),
			},
		}
	case "NewImplementation":
		event := new(joetroller.JoetrollerNewImplementation)
		if err := avaxclient.UnpackLog(joetrollerAbi, event, "NewImplementation", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetroller_newimplementation"],
			Key:   kafkautils.NewKey(Namespace, "NewImplementation"),
			ProtoMsg: &joetroller.NewImplementation{
				Ts:                common.UnixToTimestampPb(int64(ts * 1000)),
				OldImplementation: event.OldImplementation.Bytes(),
				NewImplementation: event.NewImplementation.Bytes(),
			},
		}
	case "NewPendingAdmin":
		event := new(joetroller.JoetrollerNewPendingAdmin)
		if err := avaxclient.UnpackLog(joetrollerAbi, event, "NewPendingAdmin", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetroller_newpendingadmin"],
			Key:   kafkautils.NewKey(Namespace, "NewPendingAdmin"),
			ProtoMsg: &joetroller.NewPendingAdmin{
				Ts:              common.UnixToTimestampPb(int64(ts * 1000)),
				OldPendingAdmin: event.OldPendingAdmin.Bytes(),
				NewPendingAdmin: event.NewPendingAdmin.Bytes(),
			},
		}
	case "NewPendingImplementation":
		event := new(joetroller.JoetrollerNewPendingImplementation)
		if err := avaxclient.UnpackLog(joetrollerAbi, event, "NewPendingImplementation", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["joetroller_newpendingimplementation"],
			Key:   kafkautils.NewKey(Namespace, "NewPendingImplementation"),
			ProtoMsg: &joetroller.NewPendingImplementation{
				Ts:                       common.UnixToTimestampPb(int64(ts * 1000)),
				OldPendingImplementation: event.OldPendingImplementation.Bytes(),
				NewPendingImplementation: event.NewPendingImplementation.Bytes(),
			},
		}
	}

	return nil
}

func (c *Connector) MasterChefJoeV2LogToMsg(evLog types.Log) *kafkautils.Message {
	ts, err := c.AvaxClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	masterchefjoev2Abi, err := abi.JSON(strings.NewReader(masterchefjoev2.Masterchefjoev2ABI))
	if err != nil {
		log.Error().Err(err).Msg("Failed to read Masterchefjoev2 ABI")
		return nil
	}

	ev, err := masterchefjoev2Abi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msg("Failed to find event")
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Add":
		event := new(masterchefjoev2.Masterchefjoev2Add)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "Add", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_add"],
			Key:   kafkautils.NewKey(Namespace, "Add"),
			ProtoMsg: &masterchefjoev2.Add{
				Ts:         common.UnixToTimestampPb(int64(ts * 1000)),
				Pid:        event.Pid.Bytes(),
				AllocPoint: event.AllocPoint.Bytes(),
				LpToken:    event.LpToken.Bytes(),
				Rewarder:   event.Rewarder.Bytes(),
			},
		}
	case "Deposit":
		event := new(masterchefjoev2.Masterchefjoev2Deposit)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "Deposit", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_deposit"],
			Key:   kafkautils.NewKey(Namespace, "Deposit"),
			ProtoMsg: &masterchefjoev2.Deposit{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				User:   event.User.Bytes(),
				Pid:    event.Pid.Bytes(),
				Amount: event.Amount.Bytes(),
			},
		}
	case "EmergencyWithdraw":
		event := new(masterchefjoev2.Masterchefjoev2EmergencyWithdraw)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "EmergencyWithdraw", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_emergencywithdraw"],
			Key:   kafkautils.NewKey(Namespace, "EmergencyWithdraw"),
			ProtoMsg: &masterchefjoev2.EmergencyWithdraw{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				User:   event.User.Bytes(),
				Pid:    event.Pid.Bytes(),
				Amount: event.Amount.Bytes(),
			},
		}
	case "Harvest":
		event := new(masterchefjoev2.Masterchefjoev2Harvest)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "Harvest", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_harvest"],
			Key:   kafkautils.NewKey(Namespace, "Harvest"),
			ProtoMsg: &masterchefjoev2.Harvest{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				User:   event.User.Bytes(),
				Pid:    event.Pid.Bytes(),
				Amount: event.Amount.Bytes(),
			},
		}
	case "OwnershipTransferred":
		event := new(masterchefjoev2.Masterchefjoev2OwnershipTransferred)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "OwnershipTransferred", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_ownershiptransferred"],
			Key:   kafkautils.NewKey(Namespace, "OwnershipTransferred"),
			ProtoMsg: &masterchefjoev2.OwnershipTransferred{
				Ts:            common.UnixToTimestampPb(int64(ts * 1000)),
				PreviousOwner: event.PreviousOwner.Bytes(),
				NewOwner:      event.NewOwner.Bytes(),
			},
		}
	case "Set":
		event := new(masterchefjoev2.Masterchefjoev2Set)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "Set", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_set"],
			Key:   kafkautils.NewKey(Namespace, "Set"),
			ProtoMsg: &masterchefjoev2.Set{
				Ts:         common.UnixToTimestampPb(int64(ts * 1000)),
				Pid:        event.Pid.Bytes(),
				AllocPoint: event.AllocPoint.Bytes(),
				Rewarder:   event.Rewarder.Bytes(),
				Overwrite:  event.Overwrite,
			},
		}
	case "SetDevAddress":
		event := new(masterchefjoev2.Masterchefjoev2SetDevAddress)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "SetDevAddress", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_setdevaddress"],
			Key:   kafkautils.NewKey(Namespace, "SetDevAddress"),
			ProtoMsg: &masterchefjoev2.SetDevAddress{
				Ts:         common.UnixToTimestampPb(int64(ts * 1000)),
				OldAddress: event.OldAddress.Bytes(),
				NewAddress: event.NewAddress.Bytes(),
			},
		}
	case "UpdateEmissionRate":
		event := new(masterchefjoev2.Masterchefjoev2UpdateEmissionRate)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "UpdateEmissionRate", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_updateemissionrate"],
			Key:   kafkautils.NewKey(Namespace, "UpdateEmissionRate"),
			ProtoMsg: &masterchefjoev2.UpdateEmissionRate{
				Ts:        common.UnixToTimestampPb(int64(ts * 1000)),
				User:      event.User.Bytes(),
				JoePerSec: event.JoePerSec.Bytes(),
			},
		}
	case "UpdatePool":
		event := new(masterchefjoev2.Masterchefjoev2UpdatePool)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "UpdatePool", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_updatepool"],
			Key:   kafkautils.NewKey(Namespace, "UpdatePool"),
			ProtoMsg: &masterchefjoev2.UpdatePool{
				Ts:                  common.UnixToTimestampPb(int64(ts * 1000)),
				Pid:                 event.Pid.Bytes(),
				LastRewardTimestamp: event.LastRewardTimestamp.Bytes(),
				LpSupply:            event.LpSupply.Bytes(),
				AccJoePerShare:      event.AccJoePerShare.Bytes(),
			},
		}
	case "Withdraw":
		event := new(masterchefjoev2.Masterchefjoev2Withdraw)
		if err := avaxclient.UnpackLog(masterchefjoev2Abi, event, "Withdraw", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev2_withdraw"],
			Key:   kafkautils.NewKey(Namespace, "Withdraw"),
			ProtoMsg: &masterchefjoev2.Withdraw{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				User:   event.User.Bytes(),
				Pid:    event.Pid.Bytes(),
				Amount: event.Amount.Bytes(),
			},
		}
	}

	return nil
}

func (c *Connector) MasterChefJoeV3LogToMsg(evLog types.Log) *kafkautils.Message {
	ts, err := c.AvaxClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	masterchefjoev3Abi, err := abi.JSON(strings.NewReader(masterchefjoev3.Masterchefjoev3ABI))
	if err != nil {
		log.Error().Err(err).Msg("Failed to read Masterchefjoev3 ABI")
		return nil
	}

	ev, err := masterchefjoev3Abi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msg("Failed to find event")
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Add":
		event := new(masterchefjoev3.Masterchefjoev3Add)
		if err := avaxclient.UnpackLog(masterchefjoev3Abi, event, "Add", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev3_add"],
			Key:   kafkautils.NewKey(Namespace, "Add"),
			ProtoMsg: &masterchefjoev3.Add{
				Ts:         common.UnixToTimestampPb(int64(ts * 1000)),
				Pid:        event.Pid.Bytes(),
				AllocPoint: event.AllocPoint.Bytes(),
				LpToken:    event.LpToken.Bytes(),
				Rewarder:   event.Rewarder.Bytes(),
			},
		}
	case "Deposit":
		event := new(masterchefjoev3.Masterchefjoev3Deposit)
		if err := avaxclient.UnpackLog(masterchefjoev3Abi, event, "Deposit", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev3_deposit"],
			Key:   kafkautils.NewKey(Namespace, "Deposit"),
			ProtoMsg: &masterchefjoev3.Deposit{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				User:   event.User.Bytes(),
				Pid:    event.Pid.Bytes(),
				Amount: event.Amount.Bytes(),
			},
		}
	case "EmergencyWithdraw":
		event := new(masterchefjoev3.Masterchefjoev3EmergencyWithdraw)
		if err := avaxclient.UnpackLog(masterchefjoev3Abi, event, "EmergencyWithdraw", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev3_emergencywithdraw"],
			Key:   kafkautils.NewKey(Namespace, "EmergencyWithdraw"),
			ProtoMsg: &masterchefjoev3.EmergencyWithdraw{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				User:   event.User.Bytes(),
				Pid:    event.Pid.Bytes(),
				Amount: event.Amount.Bytes(),
			},
		}
	case "Harvest":
		event := new(masterchefjoev3.Masterchefjoev3Harvest)
		if err := avaxclient.UnpackLog(masterchefjoev3Abi, event, "Harvest", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev3_harvest"],
			Key:   kafkautils.NewKey(Namespace, "Harvest"),
			ProtoMsg: &masterchefjoev3.Harvest{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				User:   event.User.Bytes(),
				Pid:    event.Pid.Bytes(),
				Amount: event.Amount.Bytes(),
			},
		}
	case "Init":
		event := new(masterchefjoev3.Masterchefjoev3Init)
		if err := avaxclient.UnpackLog(masterchefjoev3Abi, event, "Init", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev3_init"],
			Key:   kafkautils.NewKey(Namespace, "Init"),
			ProtoMsg: &masterchefjoev3.Init{
				Ts: common.UnixToTimestampPb(int64(ts * 1000)),
			},
		}
	case "OwnershipTransferred":
		event := new(masterchefjoev3.Masterchefjoev3OwnershipTransferred)
		if err := avaxclient.UnpackLog(masterchefjoev3Abi, event, "OwnershipTransferred", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev3_ownershiptransferred"],
			Key:   kafkautils.NewKey(Namespace, "OwnershipTransferred"),
			ProtoMsg: &masterchefjoev3.OwnershipTransferred{
				Ts:            common.UnixToTimestampPb(int64(ts * 1000)),
				PreviousOwner: event.PreviousOwner.Bytes(),
				NewOwner:      event.NewOwner.Bytes(),
			},
		}
	case "Set":
		event := new(masterchefjoev3.Masterchefjoev3Set)
		if err := avaxclient.UnpackLog(masterchefjoev3Abi, event, "Set", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev3_set"],
			Key:   kafkautils.NewKey(Namespace, "Set"),
			ProtoMsg: &masterchefjoev3.Set{
				Ts:         common.UnixToTimestampPb(int64(ts * 1000)),
				Pid:        event.Pid.Bytes(),
				AllocPoint: event.AllocPoint.Bytes(),
				Rewarder:   event.Rewarder.Bytes(),
				Overwrite:  event.Overwrite,
			},
		}
	case "UpdatePool":
		event := new(masterchefjoev3.Masterchefjoev3UpdatePool)
		if err := avaxclient.UnpackLog(masterchefjoev3Abi, event, "UpdatePool", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev3_updatepool"],
			Key:   kafkautils.NewKey(Namespace, "UpdatePool"),
			ProtoMsg: &masterchefjoev3.UpdatePool{
				Ts:                  common.UnixToTimestampPb(int64(ts * 1000)),
				Pid:                 event.Pid.Bytes(),
				LastRewardTimestamp: event.LastRewardTimestamp.Bytes(),
				LpSupply:            event.LpSupply.Bytes(),
				AccJoePerShare:      event.AccJoePerShare.Bytes(),
			},
		}
	case "Withdraw":
		event := new(masterchefjoev3.Masterchefjoev3Withdraw)
		if err := avaxclient.UnpackLog(masterchefjoev3Abi, event, "Withdraw", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["masterchefjoev3_withdraw"],
			Key:   kafkautils.NewKey(Namespace, "Withdraw"),
			ProtoMsg: &masterchefjoev3.Withdraw{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				User:   event.User.Bytes(),
				Pid:    event.Pid.Bytes(),
				Amount: event.Amount.Bytes(),
			},
		}
	}

	return nil
}

// Backfill last 100 blocks
func (c *Connector) backfill(out chan<- *kafkautils.Message, latestBlockNumber, backfillNumBlocks uint64, contract string, logToMsg func(types.Log) *kafkautils.Message) {
	filterQuery := interfaces.FilterQuery{
		FromBlock: big.NewInt(int64(latestBlockNumber - backfillNumBlocks)),
		ToBlock:   big.NewInt(int64(latestBlockNumber)),
		Addresses: c.addresses[contract],
	}

	logchan := make(chan types.Log)
	errchan := make(chan error)

	go c.AvaxClientPool.ChunkedFilterLogs(context.Background(), filterQuery, 100, 1, logchan, errchan)

	maxWorkers := runtime.GOMAXPROCS(0)
	sem := semaphore.NewWeighted(int64(maxWorkers))

	for {
		select {
		case err := <-errchan:
			log.Error().Err(err).Msg("Failed to complete backfill")
		case evLog := <-logchan:
			if err := sem.Acquire(context.Background(), 1); err != nil {
				log.Error().Err(err).Msg("Failed to acquire semaaphor")
			}

			go func(evLog types.Log) {
				defer sem.Release(1)

				// Writes to out chan
				msg := logToMsg(evLog)
				if msg != nil {
					out <- msg
				}
			}(evLog)
		}
	}
}

func (c *Connector) InsertPairAddress(event *joefactory.JoefactoryPairCreated) {
	// Code for storing the address in the DB
	retries := 0

	for retries <= 2 {
		t0, _ := c.tokenCache.Get(event.Token0)
		t1, _ := c.tokenCache.Get(event.Token1)

		if t0 != nil && t1 != nil {
			pair := &common.Pair{
				Ns:     TokenNamespace,
				App:    Namespace,
				Id:     event.Pair.Bytes(),
				Added:  timestamppb.Now(),
				I:      -1,
				Token0: event.Token0.Bytes(),
				Token1: event.Token1.Bytes(),
				Idh:    event.Pair.Hex(),
				D0:     t0.Decimals,
				N0:     t0.Name,
				S0:     t0.Symbol,
				D1:     t1.Decimals,
				N1:     t1.Name,
				S1:     t1.Symbol,
			}

			log.Debug().
				Hex("pair", pair.Id).
				Hex("token0", pair.Token0).
				Hex("token1", pair.Token1).
				Msg("Writing pair to db")

			err := pair.Insert(c.Db)
			if err != nil {
				log.Error().Err(err).
					Hex("pair", pair.Id).
					Hex("token0", pair.Token0).
					Hex("token1", pair.Token1).
					Msg("Unable to write result to db")
			}

			break
		}

		time.Sleep(time.Duration(1) * time.Second)
		retries++
	}
}

const batchSize = 100000

func (c *Connector) GetFactoryLogs() []types.Log {
	lastBlock := c.Db.GetLastBlockQueried(TokenNamespace, Namespace, big.NewInt(factoryContractBlock))
	latestBlock, _ := c.AvaxClientPool.BlockNumber(context.Background())
	log.Info().Str("lastBlock", lastBlock.String()).Msg("lastBlock")
	log.Info().Uint64("latestBlock", latestBlock).Msg("latestBlock")

	fromBlock := lastBlock.Uint64()
	toBlock := lastBlock.Uint64() + batchSize

	eventSignature := []byte("PairCreated(address,address,address,uint256)")
	hash := crypto.Keccak256Hash(eventSignature)

	var factoryLogs []types.Log
	// We limit the filter call here to a range of 10000 blocks, so we do not hit limits instead
	// of doing 1 big filter call.
	for toBlock < latestBlock {

		query := interfaces.FilterQuery{
			FromBlock: new(big.Int).SetUint64(fromBlock),
			ToBlock:   new(big.Int).SetUint64(toBlock),
			Addresses: c.addresses["joefactory"],
			Topics:    [][]ethcommon.Hash{{hash}},
		}

		log.Info().Str("lastBlockQueried", lastBlock.String()).Msg("Filtering PairCreated Logs from FactoryAddress. NOTE that this operation may take several minutes")

		logs, err := c.AvaxClientPool.FilterLogs(context.Background(), query)
		if err != nil {
			log.Error().Err(err).Msg("Failed filtering for PairCreated events")
			return factoryLogs
		}
		factoryLogs = append(factoryLogs, logs...)

		c.Db.UpdatelastBlock(TokenNamespace, Namespace, toBlock)
		fromBlock += batchSize
		toBlock += batchSize
	}

	if toBlock > latestBlock {
		toBlock = latestBlock
	}

	query := interfaces.FilterQuery{
		FromBlock: new(big.Int).SetUint64(fromBlock),
		ToBlock:   new(big.Int).SetUint64(toBlock),
		Addresses: c.addresses["joefactory"],
		Topics:    [][]ethcommon.Hash{{hash}},
	}

	log.Info().Str("lastBlockQueried", lastBlock.String()).Msg("Filtering PairCreated Logs from FactoryAddress. NOTE that this operation may take several minutes")

	logs, err := c.AvaxClientPool.FilterLogs(context.Background(), query)
	if err != nil {
		log.Error().Err(err).Msg("Failed filtering for PairCreated events")
		return factoryLogs
	}
	factoryLogs = append(factoryLogs, logs...)

	c.Db.UpdatelastBlock(TokenNamespace, Namespace, toBlock)

	return factoryLogs
}

func (c *Connector) InsertPairAddresses() {
	factoryLogs := c.GetFactoryLogs()

	for _, evLog := range factoryLogs {
		contractAbi, err := abi.JSON(strings.NewReader(joefactory.JoefactoryMetaData.ABI))
		if err != nil {
			log.Error().Err(err).Msg("Failed to read traderjoe pool abi")
			continue
		}

		ev, err := contractAbi.EventByID(evLog.Topics[0])
		if err != nil {
			log.Error().Err(err).Msg("failed to find event")
			continue
		}

		if ev != nil && ev.Name == "PairCreated" {
			event := new(joefactory.JoefactoryPairCreated)
			if err := avaxclient.UnpackLog(contractAbi, event, "PairCreated", evLog); err != nil {
				log.Error().Err(err).Msg("Unpack PairCreated event error")
			}

			log.Info().
				Str("token0", event.Token0.Hex()).
				Str("token1", event.Token1.Hex()).
				Msg("Inserting pair from PairCreated event")

			c.InsertPairAddress(event)
		}
	}
}

// Block with the traderjoe's Factory contract creation
const factoryContractBlock = 2486392

// Returns either the Factory contract's block number where it was created or the block number
// we last queried for PairCreated logs. We use this block number as starting point for filter
// logs so the traderjoe connector will filter through fewer logs every time it is start up.
func (c *Connector) getLastBlockQueried() int64 {
	sql, args, err := sq.
		Select("block_number").
		From("last_block_queried").
		Where(sq.Eq{"app": Namespace, "ns": TokenNamespace}).
		PlaceholderFormat(sq.Dollar).
		ToSql()
	if err != nil {
		log.Error().Err(err).Msg("Failed to build sql for getting last block queried")
	}

	rows, err := c.Db.Query(context.Background(), sql, args...)
	if err != nil {
		log.Error().Err(err).Msg("Failed to query last block queried")
	}
	defer rows.Close()

	var n int64
	if rows.Next() {
		err = rows.Scan(&n)
		if err != nil {
			log.Error().Err(err).Msg("Failed to read query of last block queried")
		}
	}

	if rows.Err() != nil {
		log.Error().Err(rows.Err()).Msg("Failed to read query of last block queried")
	}

	if n > factoryContractBlock {
		return n
	}

	return factoryContractBlock
}

func GetJoePairAddresses(db *database.Database) []ethcommon.Address {
	// Insert code here to query for all the dynamic contract's addresses from the DB and return them
	pairs, err := db.AllPairAddresses(TokenNamespace, Namespace)
	if err != nil {
		log.Fatal().Err(err).Msg("Could not get Pool Addresses from DB")
	}
	return pairs
}
