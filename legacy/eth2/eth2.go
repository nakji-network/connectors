// Code generated by connectorgen - Edit as necessary.
package eth2

import (
	"context"
	"encoding/binary"
	"fmt"
	"math/big"
	"runtime"
	"strings"
	"sync"
	"time"

	"blep.ai/data/chain/ethereum/ethclient"
	"blep.ai/data/common"
	"blep.ai/data/connectors/source/eth2/eth2"
	"github.com/nakji-network/connector/kafkautils"

	geth "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	ethcommon "github.com/ethereum/go-ethereum/common"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/rs/zerolog/log"
	"golang.org/x/sync/semaphore"
	"google.golang.org/protobuf/types/known/timestamppb"
)

const (
	Namespace                 = "eth2"
	TokenNamespace            = "ethereum"
	DepositCountQueryDuration = 3 * time.Second
)

type Eth2Connector struct {
	KP         kafkautils.ProducerInterface
	Topics     map[string]kafkautils.Topic
	ClientPool ethclient.ETHClientPool
	addresses  map[string][]ethcommon.Address
	blockCache map[uint64]uint64
}

func NewConnector(
	kp kafkautils.ProducerInterface,
	addresses map[string][]ethcommon.Address,
	topics map[string]kafkautils.Topic,
	ethClientPool ethclient.ETHClientPool,

) *Eth2Connector {
	var blockCache map[uint64]uint64

	return &Eth2Connector{
		KP:         kp,
		Topics:     topics,
		ClientPool: ethClientPool,
		addresses:  addresses,
		blockCache: blockCache,
	}
}

func (c *Eth2Connector) queryDepositCount(sink chan *kafkautils.Message) {
	instance, err := eth2.NewEth2Caller(c.addresses["eth2"][0], c.ClientPool)
	if err != nil {
		log.Fatal().Err(err).Msg("Invalid Caller failed")
	}

	for range time.NewTicker(DepositCountQueryDuration).C {

		depositCount, err := instance.GetDepositCount(nil)

		if err != nil {
			log.Warn().Err(err).Msg("GetDepositCount failed")
		}

		var depositCountInt uint64 = 0

		if len(depositCount) != 0 {
			depositCountInt = binary.LittleEndian.Uint64(depositCount)
		}

		msg := &kafkautils.Message{
			Topic: c.Topics["eth2_depositcount"],
			Key:   kafkautils.NewKey(Namespace, "DepositCount"),
			ProtoMsg: &eth2.DepositCount{
				Ts:    timestamppb.Now(),
				Count: depositCountInt,
			},
		}

		if msg != nil {
			sink <- msg
		}
	}
}

func (c *Eth2Connector) Start(ctx context.Context, backfillNumBlocks uint64) {
	// Mainly serves as Keepalive for websocket connection to RPC endpoint by subscribing to new heads
	unsubscribe := make(chan interface{})
	headers := c.ClientPool.ConsumeHeaders(unsubscribe)

	// Calls startListener
	eth2Logs, sub0 := c.startListener(ctx, "eth2")

	sink := make(chan *kafkautils.Message, 10000)

	// KAFKA ENABLE
	err := c.KP.EnableTransactions()
	if err != nil {
		log.Fatal().Err(err).Msg("Transaction was not enabled")
	}

	// GOROUTINES
	go c.KP.WriteAndCommitSink(sink)

	// Uncomment to query Deposit amount of ETH in the contract
	// go c.queryDepositCount(sink)

	// SYNC ONCE
	var once sync.Once
	for {
		select {
		case <-ctx.Done():
			log.Info().Msg("worker cancelled and shutting down")
			return
		case header := <-headers:
			log.Debug().
				Str("block", header.Number.String()).
				Uint64("ts", header.Time).
				Msg("header received")

			ethclient.CacheBlockTimestamp(header.Hash(), header.Time)
		case err := <-sub0.Err():
			log.Error().Err(err).Msg("Event listener failed")
			return
		case evLog := <-eth2Logs:
			if evLog.Removed {
				continue
			}

			go once.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "eth2", c.Eth2LogToMsg)
			})

			msg := c.Eth2LogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		}
	}
}

func (c *Eth2Connector) startListener(ctx context.Context, contractName string) (chan ethtypes.Log, event.Subscription) {
	query := geth.FilterQuery{
		Addresses: c.addresses[contractName],
	}
	eventLogs := make(chan ethtypes.Log)
	sub, err := c.ClientPool.SubscribeFilterLogs(ctx, query, eventLogs)
	if err != nil {
		msg := fmt.Sprintf("%s contract listener failed", contractName)
		log.Fatal().Err(err).
			Interface("query", query).
			Msg(msg)
	}
	msg := fmt.Sprintf("%s contract listener live", contractName)
	log.Info().Interface("query", query).Msg(msg)

	return eventLogs, sub
}

func (c *Eth2Connector) Eth2LogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	eth2Abi, err := abi.JSON(strings.NewReader(eth2.Eth2ABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Eth2 ABI")
	}

	ev, err := eth2Abi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "DepositEvent":
		event := new(eth2.Eth2DepositEvent)
		if err := ethclient.UnpackLog(eth2Abi, event, "DepositEvent", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		// Default amount should be zero for empty byte array
		var amountInt uint64 = 0

		if len(event.Amount) != 0 {
			amountInt = binary.LittleEndian.Uint64(event.Amount)
		}

		return &kafkautils.Message{
			Topic: c.Topics["eth2_depositevent"],
			Key:   kafkautils.NewKey(Namespace, "DepositEvent"),
			ProtoMsg: &eth2.DepositEvent{
				Ts:                    common.UnixToTimestampPb(int64(ts * 1000)),
				Pubkey:                event.Pubkey,
				WithdrawalCredentials: event.WithdrawalCredentials,
				Amount:                amountInt,
				Signature:             event.Signature,
				Index:                 event.Index,
			},
		}
	}

	return nil
}

// Backfill last 100 blocks
func (c *Eth2Connector) backfill(out chan<- *kafkautils.Message, latestBlockNumber, backfillNumBlocks uint64, contract string, logToMsg func(ethtypes.Log) *kafkautils.Message) {
	filterQuery := geth.FilterQuery{
		FromBlock: big.NewInt(int64(latestBlockNumber - backfillNumBlocks)),
		ToBlock:   big.NewInt(int64(latestBlockNumber)),
		Addresses: c.addresses[contract],
	}

	logchan := make(chan ethtypes.Log)
	errchan := make(chan error)

	go c.ClientPool.ChunkedFilterLogs(context.Background(), filterQuery, 100, 1, logchan, errchan)

	maxWorkers := runtime.GOMAXPROCS(0)
	sem := semaphore.NewWeighted(int64(maxWorkers))

	for {
		select {
		case err := <-errchan:
			log.Error().Err(err).Msg("Failed to complete backfill")
		case evLog := <-logchan:
			if err := sem.Acquire(context.Background(), 1); err != nil {
				log.Error().Err(err).Msg("Failed to acquire semaaphor")
			}

			go func(evLog ethtypes.Log) {
				defer sem.Release(1)

				// Writes to out chan
				msg := logToMsg(evLog)
				if msg != nil {
					out <- msg
				}
			}(evLog)
		}
	}
}
