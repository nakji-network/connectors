// Code generated by connectorgen - Edit as necessary.
package uniswapv3

import (
	"context"
	"fmt"
	"math/big"
	"runtime"
	"strings"
	"sync"
	"time"

	"blep.ai/data/chain/ethereum/ethclient"
	"blep.ai/data/common"
	"blep.ai/data/connectors/source/uniswapv3/factory"
	"blep.ai/data/connectors/source/uniswapv3/pool"
	"blep.ai/data/database"
	"blep.ai/data/tokencache"
	"github.com/nakji-network/connector/kafkautils"

	geth "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	ethcommon "github.com/ethereum/go-ethereum/common"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/rs/zerolog/log"
	"golang.org/x/sync/semaphore"
	"google.golang.org/protobuf/types/known/timestamppb"
)

const (
	App       = "uniswapv3"
	Namespace = "ethereum"
)

type Uniswapv3Connector struct {
	KP         kafkautils.ProducerInterface
	Topics     map[string]kafkautils.Topic
	ClientPool ethclient.ETHClientPool
	addresses  map[string][]ethcommon.Address
	blockCache map[uint64]uint64
	tokenCache tokencache.TokenCacheInterface
	Db         *database.Database
}

func NewConnector(
	kp kafkautils.ProducerInterface,
	addresses map[string][]ethcommon.Address,
	topics map[string]kafkautils.Topic,
	ethClientPool ethclient.ETHClientPool,
	db *database.Database,
	tokenCache tokencache.TokenCacheInterface,
) *Uniswapv3Connector {
	var blockCache map[uint64]uint64

	return &Uniswapv3Connector{
		KP:         kp,
		Topics:     topics,
		ClientPool: ethClientPool,
		addresses:  addresses,
		blockCache: blockCache,
		tokenCache: tokenCache,
		Db:         db,
	}
}

func (c *Uniswapv3Connector) Start(ctx context.Context, backfillNumBlocks uint64) {
	c.InsertPoolAddresses(context.Background())
	// Mainly serves as Keepalive for websocket connection to RPC endpoint by subscribing to new heads
	unsubscribe := make(chan interface{})
	headers := c.ClientPool.ConsumeHeaders(unsubscribe)

	factoryLogs := make(chan ethtypes.Log)
	factoryErrChan := c.startListener(ctx, "factory", factoryLogs)

	poolLogs := make(chan ethtypes.Log)
	poolErrChan := c.startListener(ctx, "pool", poolLogs)

	sink := make(chan *kafkautils.Message, 10000)
	errorSubs := []<-chan error{factoryErrChan, poolErrChan}
	out := common.MergeErrChans(errorSubs...)

	err := c.KP.EnableTransactions()
	if err != nil {
		log.Fatal().Err(err).Msg("Transaction was not enabled")
	}
	go c.KP.WriteAndCommitSink(sink)

	var once sync.Once
	for {
		select {
		case <-ctx.Done():
			log.Info().Msg("worker cancelled and shutting down")
			return
		case header := <-headers:
			log.Debug().
				Str("block", header.Number.String()).
				Uint64("ts", header.Time).
				Msg("header received")

			ethclient.CacheBlockTimestamp(header.Hash(), header.Time)
		case err = <-out:
			log.Fatal().Err(err).Msg("Event listener failed")
			return
		case evLog := <-factoryLogs:
			if evLog.Removed {
				continue
			}

			msg := c.FactoryLogToMsg(evLog, errorSubs, poolLogs)
			if msg != nil {
				sink <- msg
			}
		case evLog := <-poolLogs:
			if evLog.Removed {
				continue
			}

			go once.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "pool", c.PoolLogToMsg)
			})

			msg := c.PoolLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		}
	}
}

func (c *Uniswapv3Connector) startListener(ctx context.Context, contractName string, logch chan ethtypes.Log) <-chan error {
	query := geth.FilterQuery{
		Addresses: c.addresses[contractName],
	}

	errch, err := c.ClientPool.ChunkedSubscribeFilterLogs(ctx, query, logch, 0)
	if err != nil {
		msg := fmt.Sprintf("%s contract listener failed", contractName)
		log.Fatal().Err(err).
			Interface("query", query).
			Msg(msg)
	}
	msg := fmt.Sprintf("%s contract listener live", contractName)
	log.Info().Interface("query", query).Msg(msg)

	return errch
}

func (c *Uniswapv3Connector) FactoryLogToMsg(evLog ethtypes.Log, errorSubs []<-chan error, poolLogs chan ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	factoryAbi, err := abi.JSON(strings.NewReader(factory.FactoryABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Factory ABI")
	}

	ev, err := factoryAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msg("Failed to find event")
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "FeeAmountEnabled":
		event := new(factory.FactoryFeeAmountEnabled)
		if err := ethclient.UnpackLog(factoryAbi, event, "FeeAmountEnabled", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["factoryfeeamountenabled"],
			Key:   kafkautils.NewKey(App, "feeamountenabled"),
			ProtoMsg: &factory.FeeAmountEnabled{
				Ts:          common.UnixToTimestampPb(int64(ts * 1000)),
				Fee:         event.Fee.Bytes(),
				TickSpacing: event.TickSpacing.Bytes(),
			},
		}
	case "OwnerChanged":
		event := new(factory.FactoryOwnerChanged)
		if err := ethclient.UnpackLog(factoryAbi, event, "OwnerChanged", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["factoryownerchanged"],
			Key:   kafkautils.NewKey(App, "ownerchanged"),
			ProtoMsg: &factory.OwnerChanged{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldOwner: event.OldOwner.Bytes(),
				NewOwner: event.NewOwner.Bytes(),
			},
		}
	case "PoolCreated":
		event := new(factory.FactoryPoolCreated)
		if err := ethclient.UnpackLog(factoryAbi, event, "PoolCreated", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}
		c.InsertPoolAddress(event)
		query := geth.FilterQuery{
			Addresses: []ethcommon.Address{event.Pool},
		}
		sub, err := c.ClientPool.SubscribeFilterLogs(context.Background(), query, poolLogs)
		if err != nil {
			log.Fatal().Err(err).
				Interface("query", query).
				Msg("Subscribe pool failed to subscribe")
		}

		errorSubs = append(errorSubs, sub.Err())

		return &kafkautils.Message{
			Topic: c.Topics["factorypoolcreated"],
			Key:   kafkautils.NewKey(App, "poolcreated"),
			ProtoMsg: &factory.PoolCreated{
				Ts:          common.UnixToTimestampPb(int64(ts * 1000)),
				Token0:      event.Token0.Bytes(),
				Token1:      event.Token1.Bytes(),
				Fee:         event.Fee.Bytes(),
				TickSpacing: event.TickSpacing.Bytes(),
				Pool:        event.Pool.Bytes(),
			},
		}
	}

	return nil
}
func (c *Uniswapv3Connector) PoolLogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	poolAbi, err := abi.JSON(strings.NewReader(pool.PoolABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Pool ABI")
	}

	ev, err := poolAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Error().Err(err).Msg("Failed to find event")
		return nil
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Burn":
		event := new(pool.PoolBurn)
		if err := ethclient.UnpackLog(poolAbi, event, "Burn", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["poolburn"],
			Key:   kafkautils.NewKey(App, "burn"),
			ProtoMsg: &pool.Burn{
				Ts:        common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:     event.Owner.Bytes(),
				TickLower: event.TickLower.Bytes(),
				TickUpper: event.TickUpper.Bytes(),
				Amount:    event.Amount.Bytes(),
				Amount0:   event.Amount0.Bytes(),
				Amount1:   event.Amount1.Bytes(),
			},
		}
	case "Collect":
		event := new(pool.PoolCollect)
		if err := ethclient.UnpackLog(poolAbi, event, "Collect", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["poolcollect"],
			Key:   kafkautils.NewKey(App, "collect"),
			ProtoMsg: &pool.Collect{
				Ts:        common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:     event.Owner.Bytes(),
				Recipient: event.Recipient.Bytes(),
				TickLower: event.TickLower.Bytes(),
				TickUpper: event.TickUpper.Bytes(),
				Amount0:   event.Amount0.Bytes(),
				Amount1:   event.Amount1.Bytes(),
			},
		}
	case "CollectProtocol":
		event := new(pool.PoolCollectProtocol)
		if err := ethclient.UnpackLog(poolAbi, event, "CollectProtocol", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["poolcollectprotocol"],
			Key:   kafkautils.NewKey(App, "collectprotocol"),
			ProtoMsg: &pool.CollectProtocol{
				Ts:        common.UnixToTimestampPb(int64(ts * 1000)),
				Sender:    event.Sender.Bytes(),
				Recipient: event.Recipient.Bytes(),
				Amount0:   event.Amount0.Bytes(),
				Amount1:   event.Amount1.Bytes(),
			},
		}
	case "Flash":
		event := new(pool.PoolFlash)
		if err := ethclient.UnpackLog(poolAbi, event, "Flash", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["poolflash"],
			Key:   kafkautils.NewKey(App, "flash"),
			ProtoMsg: &pool.Flash{
				Ts:        common.UnixToTimestampPb(int64(ts * 1000)),
				Sender:    event.Sender.Bytes(),
				Recipient: event.Recipient.Bytes(),
				Amount0:   event.Amount0.Bytes(),
				Amount1:   event.Amount1.Bytes(),
				Paid0:     event.Paid0.Bytes(),
				Paid1:     event.Paid1.Bytes(),
			},
		}
	case "IncreaseObservationCardinalityNext":
		event := new(pool.PoolIncreaseObservationCardinalityNext)
		if err := ethclient.UnpackLog(poolAbi, event, "IncreaseObservationCardinalityNext", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["poolincreaseobservationcardinalitynext"],
			Key:   kafkautils.NewKey(App, "increaseobservationcardinalitynext"),
			ProtoMsg: &pool.IncreaseObservationCardinalityNext{
				Ts:                            common.UnixToTimestampPb(int64(ts * 1000)),
				ObservationCardinalityNextOld: uint32(event.ObservationCardinalityNextOld),
				ObservationCardinalityNextNew: uint32(event.ObservationCardinalityNextNew),
			},
		}
	case "Initialize":
		event := new(pool.PoolInitialize)
		if err := ethclient.UnpackLog(poolAbi, event, "Initialize", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["poolinitialize"],
			Key:   kafkautils.NewKey(App, "initialize"),
			ProtoMsg: &pool.Initialize{
				Ts:           common.UnixToTimestampPb(int64(ts * 1000)),
				SqrtPriceX96: event.SqrtPriceX96.Bytes(),
				Tick:         event.Tick.Bytes(),
			},
		}
	case "Mint":
		event := new(pool.PoolMint)
		if err := ethclient.UnpackLog(poolAbi, event, "Mint", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["poolmint"],
			Key:   kafkautils.NewKey(App, "mint"),
			ProtoMsg: &pool.Mint{
				Ts:        common.UnixToTimestampPb(int64(ts * 1000)),
				Sender:    event.Sender.Bytes(),
				Owner:     event.Owner.Bytes(),
				TickLower: event.TickLower.Bytes(),
				TickUpper: event.TickUpper.Bytes(),
				Amount:    event.Amount.Bytes(),
				Amount0:   event.Amount0.Bytes(),
				Amount1:   event.Amount1.Bytes(),
			},
		}
	case "SetFeeProtocol":
		event := new(pool.PoolSetFeeProtocol)
		if err := ethclient.UnpackLog(poolAbi, event, "SetFeeProtocol", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["poolsetfeeprotocol"],
			Key:   kafkautils.NewKey(App, "setfeeprotocol"),
			ProtoMsg: &pool.SetFeeProtocol{
				Ts:              common.UnixToTimestampPb(int64(ts * 1000)),
				FeeProtocol0Old: uint32(event.FeeProtocol0Old),
				FeeProtocol1Old: uint32(event.FeeProtocol1Old),
				FeeProtocol0New: uint32(event.FeeProtocol0New),
				FeeProtocol1New: uint32(event.FeeProtocol1New),
			},
		}
	case "Swap":
		event := new(pool.PoolSwap)
		if err := ethclient.UnpackLog(poolAbi, event, "Swap", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["poolswap"],
			Key:   kafkautils.NewKey(App, "swap"),
			ProtoMsg: &pool.Swap{
				Ts:           common.UnixToTimestampPb(int64(ts * 1000)),
				Sender:       event.Sender.Bytes(),
				Recipient:    event.Recipient.Bytes(),
				Amount0:      event.Amount0.Bytes(),
				Amount1:      event.Amount1.Bytes(),
				SqrtPriceX96: event.SqrtPriceX96.Bytes(),
				Liquidity:    event.Liquidity.Bytes(),
				Tick:         event.Tick.Bytes(),
			},
		}
	}

	return nil
}

// Backfill last 100 blocks
func (c *Uniswapv3Connector) backfill(out chan<- *kafkautils.Message, latestBlockNumber, backfillNumBlocks uint64, contract string, logToMsg func(ethtypes.Log) *kafkautils.Message) {
	filterQuery := geth.FilterQuery{
		FromBlock: big.NewInt(int64(latestBlockNumber - backfillNumBlocks)),
		ToBlock:   big.NewInt(int64(latestBlockNumber)),
		Addresses: c.addresses[contract],
	}

	logchan := make(chan ethtypes.Log)
	errchan := make(chan error)

	go c.ClientPool.ChunkedFilterLogs(context.Background(), filterQuery, 100, 1, logchan, errchan)

	maxWorkers := runtime.GOMAXPROCS(0)
	sem := semaphore.NewWeighted(int64(maxWorkers))

	for {
		select {
		case err := <-errchan:
			log.Error().Err(err).Msg("Failed to complete backfill")
		case evLog := <-logchan:
			if err := sem.Acquire(context.Background(), 1); err != nil {
				log.Error().Err(err).Msg("Failed to acquire semaaphor")
			}

			go func(evLog ethtypes.Log) {
				defer sem.Release(1)

				// Writes to out chan
				msg := logToMsg(evLog)
				if msg != nil {
					out <- msg
				}
			}(evLog)
		}
	}
}

func (c *Uniswapv3Connector) InsertPoolAddress(event *factory.FactoryPoolCreated) {
	retries := 0

	for retries <= 2 {
		t0, _ := c.tokenCache.Get(event.Token0)
		t1, _ := c.tokenCache.Get(event.Token1)

		if t0 != nil && t1 != nil {
			pair := &common.Pair{
				Ns:     Namespace,
				App:    App,
				Id:     event.Pool.Bytes(),
				Added:  timestamppb.Now(),
				I:      event.Fee.Int64(),
				Token0: event.Token0.Bytes(),
				Token1: event.Token1.Bytes(),
				Idh:    event.Pool.Hex(),
				D0:     t0.Decimals,
				N0:     t0.Name,
				S0:     t0.Symbol,
				D1:     t1.Decimals,
				N1:     t1.Name,
				S1:     t1.Symbol,
			}

			err := pair.Insert(c.Db)
			if err != nil {
				log.Error().Err(err).
					Hex("pair", pair.Id).
					Hex("token0", pair.Token0).
					Hex("token1", pair.Token1).
					Msg("Unable to write result to db")
			}

			break
		}

		time.Sleep(time.Duration(1) * time.Second)
		retries++
	}
}

// Block with the UniswapV3's Factory contract creation
var factoryContractBlock = big.NewInt(12369621)

const batchSize = 1000

func (c *Uniswapv3Connector) InsertPoolAddresses(ctx context.Context) {

	lastBlock := c.Db.GetLastBlockQueried(Namespace, App, factoryContractBlock).Uint64()

	log.Info().Uint64("lastBlockQueried", lastBlock).Msg("Filtering PoolCreated Logs from FactoryAddress. NOTE that this operation may take several minutes")

	filterer, err := factory.NewFactoryFilterer(c.addresses["factory"][0], c.ClientPool)
	if err != nil {
		log.Fatal().Err(err).Msg("FactoryFilterer failed")
	}

	latestBlock, err := c.ClientPool.BlockNumber(ctx)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to get latest block number")
	}

	fromBlock := lastBlock
	toBlock := lastBlock + batchSize

	for fromBlock < latestBlock {
		opts := &bind.FilterOpts{Start: fromBlock, End: &toBlock, Context: context.Background()}
		factoryPoolCreatedIterator, err := filterer.FilterPoolCreated(opts, []ethcommon.Address{}, []ethcommon.Address{}, nil)
		if err != nil {
			log.Fatal().Err(err).Msg("FilterPoolCreated failed")
		}

		if err != nil {
			log.Error().Err(err).Msg("Failed filtering for PoolCreated events")
		}

		for factoryPoolCreatedIterator.Next() {
			event := factoryPoolCreatedIterator.Event

			log.Info().
				Str("token0", event.Token0.Hex()).
				Str("token1", event.Token1.Hex()).
				Msg("Inserting pair from PoolCreated event")

			c.InsertPoolAddress(event)
		}

		c.Db.UpdatelastBlock(Namespace, App, toBlock)
		fromBlock = toBlock
		toBlock += batchSize
	}
}

func GetPoolAddresses(db *database.Database) []ethcommon.Address {
	pairs, err := db.AllPairAddresses(Namespace, App)
	if err != nil {
		log.Fatal().Err(err).Msg("Could not get Pool Addresses from DB")
	}
	return pairs
}
