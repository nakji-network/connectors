// Code generated by connectorgen - Edit as necessary.

package main

import (
	"context"
	"net/http"

	"blep.ai/data/chain/ethereum/ethclient"
	"blep.ai/data/config"
	"blep.ai/data/connectors/source/uniswapv3"
	"blep.ai/data/database"
	"blep.ai/data/monitor"
	"blep.ai/data/tokencache"
	"github.com/nakji-network/connector/kafkautils"

	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/heptiolabs/healthcheck"
	"github.com/rs/zerolog/log"
)

var conf = config.GetConfig()

func init() {
	kafkautils.TopicTypeRegistry.Load(uniswapv3.TopicTypes)
	conf.SetDefault("uniswapv3.kafka.topic.factoryfeeamountenabled", ".fct.nakji.uniswapv3.0_0_0.factory_feeamountenabled")
	conf.SetDefault("uniswapv3.kafka.topic.factoryownerchanged", ".fct.nakji.uniswapv3.0_0_0.factory_ownerchanged")
	conf.SetDefault("uniswapv3.kafka.topic.factorypoolcreated", ".fct.nakji.uniswapv3.0_0_0.factory_poolcreated")
	conf.SetDefault("uniswapv3.kafka.topic.poolburn", ".fct.nakji.uniswapv3.0_0_0.pool_burn")
	conf.SetDefault("uniswapv3.kafka.topic.poolcollect", ".fct.nakji.uniswapv3.0_0_0.pool_collect")
	conf.SetDefault("uniswapv3.kafka.topic.poolcollectprotocol", ".fct.nakji.uniswapv3.0_0_0.pool_collectprotocol")
	conf.SetDefault("uniswapv3.kafka.topic.poolflash", ".fct.nakji.uniswapv3.0_0_0.pool_flash")
	conf.SetDefault("uniswapv3.kafka.topic.poolincreaseobservationcardinalitynext", ".fct.nakji.uniswapv3.0_0_0.pool_increaseobservationcardinalitynext")
	conf.SetDefault("uniswapv3.kafka.topic.poolinitialize", ".fct.nakji.uniswapv3.0_0_0.pool_initialize")
	conf.SetDefault("uniswapv3.kafka.topic.poolmint", ".fct.nakji.uniswapv3.0_0_0.pool_mint")
	conf.SetDefault("uniswapv3.kafka.topic.poolsetfeeprotocol", ".fct.nakji.uniswapv3.0_0_0.pool_setfeeprotocol")
	conf.SetDefault("uniswapv3.kafka.topic.poolswap", ".fct.nakji.uniswapv3.0_0_0.pool_swap")

	conf.SetDefault("uniswapv3.kafka.txID", "uniswapv3")
	conf.SetDefault("uniswapv3.backfillNumBlocks", 100)
	conf.SetDefault("uniswapv3.factoryAddress", "0x1F98431c8aD98523631AE4a59f267346ea31F984")

}

func main() {
	kp, err := kafkautils.NewProducer(conf.GetString("kafka.url"), conf.GetString("uniswapv3.kafka.txID"))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to create new kafka producer")
	}

	urls := conf.GetStringSlice("ethereum.rpc")
	log.Info().Strs("url", urls).Msg("connecting to Ethereum RPC")
	ethClientPool, err := ethclient.DialPoolContext(context.Background(), urls)
	if err != nil {
		log.Fatal().Err(err).Msg("Ethereum RPC connection error")
	}

	db, err := database.New(conf.GetString("timescaledb.connection"))
	if err != nil {
		log.Fatal().Err(err).Str("dsn", conf.GetString("timescaledb.connection")).Msg("Timescaledb connection failed")
	}
	defer db.Close()

	// For Liveness and Readiness Probe checks
	health := healthcheck.NewHandler()
	go http.ListenAndServe("0.0.0.0:8080", health)
	log.Info().Str("addr", "0.0.0.0:8080").Msg("healthcheck listening on /live and /ready")

	factoryAddress := ethcommon.HexToAddress(conf.GetString("uniswapv3.factoryAddress"))

	addresses := map[string][]ethcommon.Address{
		"factory": {factoryAddress},
		"pool":    uniswapv3.GetPoolAddresses(db),
	}

	topics := map[string]kafkautils.Topic{
		"factoryfeeamountenabled":                kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.factoryfeeamountenabled"), conf.GetString("kafka.env")),
		"factoryownerchanged":                    kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.factoryownerchanged"), conf.GetString("kafka.env")),
		"factorypoolcreated":                     kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.factorypoolcreated"), conf.GetString("kafka.env")),
		"poolburn":                               kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.poolburn"), conf.GetString("kafka.env")),
		"poolcollect":                            kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.poolcollect"), conf.GetString("kafka.env")),
		"poolcollectprotocol":                    kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.poolcollectprotocol"), conf.GetString("kafka.env")),
		"poolflash":                              kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.poolflash"), conf.GetString("kafka.env")),
		"poolincreaseobservationcardinalitynext": kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.poolincreaseobservationcardinalitynext"), conf.GetString("kafka.env")),
		"poolinitialize":                         kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.poolinitialize"), conf.GetString("kafka.env")),
		"poolmint":                               kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.poolmint"), conf.GetString("kafka.env")),
		"poolsetfeeprotocol":                     kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.poolsetfeeprotocol"), conf.GetString("kafka.env")),
		"poolswap":                               kafkautils.MustParseTopic(conf.GetString("uniswapv3.kafka.topic.poolswap"), conf.GetString("kafka.env")),
	}

	tokenCache, err := tokencache.NewTokenCache(uniswapv3.Namespace, db, ethClientPool, 18000)
	if err != nil {
		log.Fatal().Err(err).Msg("token cache failed to create")
	}

	connector := uniswapv3.NewConnector(
		kp,
		addresses,
		topics,
		ethClientPool,
		db,
		tokenCache,
	)

	monitor.StartMonitor("uniswapv3")
	connector.Start(context.Background(), conf.GetUint64("uniswapv3.backfillNumBlocks"))
}
