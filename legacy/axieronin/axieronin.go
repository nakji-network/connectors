// Code generated by connectorgen - Edit as necessary.
package axieronin

import (
	"context"
	"fmt"
	"math/big"
	"runtime"
	"strings"
	"sync"

	geth "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	ethcommon "github.com/ethereum/go-ethereum/common"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/rs/zerolog/log"

	"blep.ai/data/chain/ethereum/ethclient"
	"blep.ai/data/common"
	"blep.ai/data/connectors/source/axie/axienft"
	"blep.ai/data/connectors/source/axie/axs"
	"blep.ai/data/connectors/source/axie/slp"
	"blep.ai/data/connectors/source/axieronin/clockauction"
	"blep.ai/data/connectors/source/axieronin/land"
	"blep.ai/data/connectors/source/axieronin/landitem"
	"blep.ai/data/connectors/source/axieronin/roninweth"
	"github.com/nakji-network/connector/kafkautils"

	"golang.org/x/sync/semaphore"
)

const (
	Namespace      = "axieronin"
	TokenNamespace = "ethereum"
)

type AxieroninConnector struct {
	KP         kafkautils.ProducerInterface
	Topics     map[string]kafkautils.Topic
	ClientPool ethclient.ETHClientPool
	addresses  map[string][]ethcommon.Address
	blockCache map[uint64]uint64
}

func NewConnector(
	kp kafkautils.ProducerInterface,
	addresses map[string][]ethcommon.Address,
	topics map[string]kafkautils.Topic,
	ethClientPool ethclient.ETHClientPool,

) *AxieroninConnector {
	var blockCache map[uint64]uint64

	return &AxieroninConnector{
		KP:         kp,
		Topics:     topics,
		ClientPool: ethClientPool,
		addresses:  addresses,
		blockCache: blockCache,
	}
}

func (c *AxieroninConnector) Start(ctx context.Context, backfillNumBlocks uint64) {
	// Mainly serves as Keepalive for websocket connection to RPC endpoint by subscribing to new heads
	unsubscribe := make(chan interface{})
	headers := c.ClientPool.ConsumeHeaders(unsubscribe)
	axienftLogs, sub0 := c.startListener(ctx, "axienft")
	axsLogs, sub1 := c.startListener(ctx, "axs")
	clockauctionLogs, sub2 := c.startListener(ctx, "clockauction")
	landLogs, sub3 := c.startListener(ctx, "land")
	landitemLogs, sub4 := c.startListener(ctx, "landitem")
	roninwethLogs, sub5 := c.startListener(ctx, "roninweth")
	slpLogs, sub6 := c.startListener(ctx, "slp")

	sink := make(chan *kafkautils.Message, 10000)
	errorSubs := []<-chan error{sub0.Err(), sub1.Err(), sub2.Err(), sub3.Err(), sub4.Err(), sub5.Err(), sub6.Err()}
	out := common.MergeErrChans(errorSubs...)

	err := c.KP.EnableTransactions()
	if err != nil {
		log.Fatal().Err(err).Msg("Transaction was not enabled")
	}
	go c.KP.WriteAndCommitSink(sink)

	var once1 sync.Once
	var once2 sync.Once
	var once3 sync.Once
	var once4 sync.Once
	var once5 sync.Once
	var once6 sync.Once
	var once7 sync.Once
	for {
		select {
		case <-ctx.Done():
			log.Info().Msg("worker cancelled and shutting down")
			return
		case header := <-headers:
			log.Debug().
				Str("block", header.Number.String()).
				Uint64("ts", header.Time).
				Msg("header received")

			ethclient.CacheBlockTimestamp(header.Hash(), header.Time)
		case err = <-out:
			log.Error().Err(err).Msg("Event listener failed")
			return
		case evLog := <-axienftLogs:
			if evLog.Removed {
				continue
			}

			go once1.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "axienft", c.AxienftLogToMsg)
			})

			msg := c.AxienftLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-axsLogs:
			if evLog.Removed {
				continue
			}

			go once2.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "axs", c.AxsLogToMsg)
			})

			msg := c.AxsLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-clockauctionLogs:
			if evLog.Removed {
				continue
			}

			go once3.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "clockauction", c.ClockauctionLogToMsg)
			})

			msg := c.ClockauctionLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-landLogs:
			if evLog.Removed {
				continue
			}

			go once4.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "land", c.LandLogToMsg)
			})

			msg := c.LandLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-landitemLogs:
			if evLog.Removed {
				continue
			}

			go once5.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "landitem", c.LanditemLogToMsg)
			})

			msg := c.LanditemLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-roninwethLogs:
			if evLog.Removed {
				continue
			}

			go once6.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "roninweth", c.RoninwethLogToMsg)
			})

			msg := c.RoninwethLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-slpLogs:
			if evLog.Removed {
				continue
			}

			go once7.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "slp", c.SlpLogToMsg)
			})

			msg := c.SlpLogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		}
	}
}

func (c *AxieroninConnector) startListener(ctx context.Context, contractName string) (chan ethtypes.Log, event.Subscription) {
	query := geth.FilterQuery{
		Addresses: c.addresses[contractName],
	}
	eventLogs := make(chan ethtypes.Log)
	sub, err := c.ClientPool.SubscribeFilterLogs(ctx, query, eventLogs)
	if err != nil {
		msg := fmt.Sprintf("%s contract listener failed", contractName)
		log.Fatal().Err(err).
			Interface("query", query).
			Msg(msg)
	}
	msg := fmt.Sprintf("%s contract listener live", contractName)
	log.Info().Interface("query", query).Msg(msg)

	return eventLogs, sub
}

func (c *AxieroninConnector) AxienftLogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	axienftAbi, err := abi.JSON(strings.NewReader(axienft.AxienftABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Axienft ABI")
	}

	ev, err := axienftAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Approval":
		event := new(axienft.AxienftApproval)
		if err := ethclient.UnpackLog(axienftAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["axienft_approval"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &axienft.Approval{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:    event.Owner.Bytes(),
				Approved: event.Approved.Bytes(),
				TokenId:  event.TokenId.Bytes(),
			},
		}
	case "ApprovalForAll":
		event := new(axienft.AxienftApprovalForAll)
		if err := ethclient.UnpackLog(axienftAbi, event, "ApprovalForAll", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["axienft_approvalforall"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &axienft.ApprovalForAll{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:    event.Owner.Bytes(),
				Operator: event.Operator.Bytes(),
				Approved: event.Approved,
			},
		}
	case "AxieEvolved":
		event := new(axienft.AxienftAxieEvolved)
		if err := ethclient.UnpackLog(axienftAbi, event, "AxieEvolved", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["axienft_axieevolved"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &axienft.AxieEvolved{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				AxieId:   event.AxieId.Bytes(),
				OldGenes: event.OldGenes.Bytes(),
				NewGenes: event.NewGenes.Bytes(),
			},
		}
	case "AxieRebirthed":
		event := new(axienft.AxienftAxieRebirthed)
		if err := ethclient.UnpackLog(axienftAbi, event, "AxieRebirthed", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["axienft_axierebirthed"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &axienft.AxieRebirthed{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				AxieId: event.AxieId.Bytes(),
				Genes:  event.Genes.Bytes(),
			},
		}
	case "AxieRetired":
		event := new(axienft.AxienftAxieRetired)
		if err := ethclient.UnpackLog(axienftAbi, event, "AxieRetired", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["axienft_axieretired"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &axienft.AxieRetired{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				AxieId: event.AxieId.Bytes(),
			},
		}
	case "AxieSpawned":
		event := new(axienft.AxienftAxieSpawned)
		if err := ethclient.UnpackLog(axienftAbi, event, "AxieSpawned", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["axienft_axiespawned"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &axienft.AxieSpawned{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				AxieId: event.AxieId.Bytes(),
				Owner:  event.Owner.Bytes(),
				Genes:  event.Genes.Bytes(),
			},
		}
	case "Transfer":
		event := new(axienft.AxienftTransfer)
		if err := ethclient.UnpackLog(axienftAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["axienft_transfer"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &axienft.Transfer{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				From:    event.From.Bytes(),
				To:      event.To.Bytes(),
				TokenId: event.TokenId.Bytes(),
			},
		}
	}

	return nil
}
func (c *AxieroninConnector) AxsLogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	axsAbi, err := abi.JSON(strings.NewReader(axs.AxsABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Axs ABI")
	}

	ev, err := axsAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Approval":
		event := new(axs.AxsApproval)
		if err := ethclient.UnpackLog(axsAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["axs_approval"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &axs.Approval{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:   event.Owner.Bytes(),
				Spender: event.Spender.Bytes(),
				Value:   event.Value.Bytes(),
			},
		}
	case "Transfer":
		event := new(axs.AxsTransfer)
		if err := ethclient.UnpackLog(axsAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["axs_transfer"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &axs.Transfer{
				Ts:    common.UnixToTimestampPb(int64(ts * 1000)),
				From:  event.From.Bytes(),
				To:    event.To.Bytes(),
				Value: event.Value.Bytes(),
			},
		}
	}

	return nil
}
func (c *AxieroninConnector) ClockauctionLogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	clockauctionAbi, err := abi.JSON(strings.NewReader(clockauction.ClockauctionABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Clockauction ABI")
	}

	ev, err := clockauctionAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "AdminChanged":
		event := new(clockauction.ClockauctionAdminChanged)
		if err := ethclient.UnpackLog(clockauctionAbi, event, "AdminChanged", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["clockauction_adminchanged"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &clockauction.AdminChanged{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldAdmin: event.OldAdmin.Bytes(),
				NewAdmin: event.NewAdmin.Bytes(),
			},
		}
	case "AdminRemoved":
		event := new(clockauction.ClockauctionAdminRemoved)
		if err := ethclient.UnpackLog(clockauctionAbi, event, "AdminRemoved", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["clockauction_adminremoved"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &clockauction.AdminRemoved{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldAdmin: event.OldAdmin.Bytes(),
			},
		}
	case "AuctionCancelled":
		event := new(clockauction.ClockauctionAuctionCancelled)
		if err := ethclient.UnpackLog(clockauctionAbi, event, "AuctionCancelled", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["clockauction_auctioncancelled"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &clockauction.AuctionCancelled{
				Ts:           common.UnixToTimestampPb(int64(ts * 1000)),
				Seller:       event.Seller.Bytes(),
				ListingIndex: event.ListingIndex.Bytes(),
			},
		}
	case "AuctionCreated":
		event := new(clockauction.ClockauctionAuctionCreated)
		if err := ethclient.UnpackLog(clockauctionAbi, event, "AuctionCreated", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["clockauction_auctioncreated"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &clockauction.AuctionCreated{
				Ts:                 common.UnixToTimestampPb(int64(ts * 1000)),
				Seller:             event.Seller.Bytes(),
				ListingIndex:       event.ListingIndex.Bytes(),
				StartingPrices:     common.DecodeBigIntArray(event.StartingPrices),
				EndingPrices:       common.DecodeBigIntArray(event.EndingPrices),
				ExchangeTokens:     common.DecodeAddressArray(event.ExchangeTokens),
				Durations:          common.DecodeBigIntArray(event.Durations),
				StartingTimestamps: event.StartingTimestamps.Bytes(),
			},
		}
	case "AuctionSuccessful":
		event := new(clockauction.ClockauctionAuctionSuccessful)
		if err := ethclient.UnpackLog(clockauctionAbi, event, "AuctionSuccessful", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["clockauction_auctionsuccessful"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &clockauction.AuctionSuccessful{
				Ts:           common.UnixToTimestampPb(int64(ts * 1000)),
				Seller:       event.Seller.Bytes(),
				Buyer:        event.Buyer.Bytes(),
				ListingIndex: event.ListingIndex.Bytes(),
				Token:        event.Token.Bytes(),
				TotalPrice:   event.TotalPrice.Bytes(),
			},
		}
	case "Paused":
		event := new(clockauction.ClockauctionPaused)
		if err := ethclient.UnpackLog(clockauctionAbi, event, "Paused", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["clockauction_paused"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &clockauction.Paused{
				Ts: common.UnixToTimestampPb(int64(ts * 1000)),
			},
		}
	case "TokenAuctionCancelled":
		event := new(clockauction.ClockauctionTokenAuctionCancelled)
		if err := ethclient.UnpackLog(clockauctionAbi, event, "TokenAuctionCancelled", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["clockauction_tokenauctioncancelled"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &clockauction.TokenAuctionCancelled{
				Ts:             common.UnixToTimestampPb(int64(ts * 1000)),
				Seller:         event.Seller.Bytes(),
				ListingIndex:   event.ListingIndex.Bytes(),
				ExchangeTokens: event.ExchangeTokens.Bytes(),
			},
		}
	case "Unpaused":
		event := new(clockauction.ClockauctionUnpaused)
		if err := ethclient.UnpackLog(clockauctionAbi, event, "Unpaused", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["clockauction_unpaused"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &clockauction.Unpaused{
				Ts: common.UnixToTimestampPb(int64(ts * 1000)),
			},
		}
	}

	return nil
}
func (c *AxieroninConnector) LandLogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	landAbi, err := abi.JSON(strings.NewReader(land.LandABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Land ABI")
	}

	ev, err := landAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "AdminChanged":
		event := new(land.LandAdminChanged)
		if err := ethclient.UnpackLog(landAbi, event, "AdminChanged", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_adminchanged"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.AdminChanged{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldAdmin: event.OldAdmin.Bytes(),
				NewAdmin: event.NewAdmin.Bytes(),
			},
		}
	case "AdminRemoved":
		event := new(land.LandAdminRemoved)
		if err := ethclient.UnpackLog(landAbi, event, "AdminRemoved", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_adminremoved"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.AdminRemoved{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldAdmin: event.OldAdmin.Bytes(),
			},
		}
	case "Approval":
		event := new(land.LandApproval)
		if err := ethclient.UnpackLog(landAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_approval"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.Approval{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:    event.Owner.Bytes(),
				Approved: event.Approved.Bytes(),
				TokenId:  event.TokenId.Bytes(),
			},
		}
	case "ApprovalForAll":
		event := new(land.LandApprovalForAll)
		if err := ethclient.UnpackLog(landAbi, event, "ApprovalForAll", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_approvalforall"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.ApprovalForAll{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:    event.Owner.Bytes(),
				Operator: event.Operator.Bytes(),
				Approved: event.Approved,
			},
		}
	case "MinterAdded":
		event := new(land.LandMinterAdded)
		if err := ethclient.UnpackLog(landAbi, event, "MinterAdded", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_minteradded"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.MinterAdded{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				Minter: event.Minter.Bytes(),
			},
		}
	case "MinterRemoved":
		event := new(land.LandMinterRemoved)
		if err := ethclient.UnpackLog(landAbi, event, "MinterRemoved", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_minterremoved"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.MinterRemoved{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				Minter: event.Minter.Bytes(),
			},
		}
	case "NonceUpdated":
		event := new(land.LandNonceUpdated)
		if err := ethclient.UnpackLog(landAbi, event, "NonceUpdated", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_nonceupdated"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.NonceUpdated{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				TokenId: event.TokenId.Bytes(),
				Nonce:   event.Nonce.Bytes(),
			},
		}
	case "Paused":
		event := new(land.LandPaused)
		if err := ethclient.UnpackLog(landAbi, event, "Paused", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_paused"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.Paused{
				Ts: common.UnixToTimestampPb(int64(ts * 1000)),
			},
		}
	case "SpenderUnwhitelisted":
		event := new(land.LandSpenderUnwhitelisted)
		if err := ethclient.UnpackLog(landAbi, event, "SpenderUnwhitelisted", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_spenderunwhitelisted"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.SpenderUnwhitelisted{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Spender: event.Spender.Bytes(),
			},
		}
	case "SpenderWhitelisted":
		event := new(land.LandSpenderWhitelisted)
		if err := ethclient.UnpackLog(landAbi, event, "SpenderWhitelisted", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_spenderwhitelisted"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.SpenderWhitelisted{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Spender: event.Spender.Bytes(),
			},
		}
	case "Transfer":
		event := new(land.LandTransfer)
		if err := ethclient.UnpackLog(landAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_transfer"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.Transfer{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				From:    event.From.Bytes(),
				To:      event.To.Bytes(),
				TokenId: event.TokenId.Bytes(),
			},
		}
	case "Unpaused":
		event := new(land.LandUnpaused)
		if err := ethclient.UnpackLog(landAbi, event, "Unpaused", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["land_unpaused"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &land.Unpaused{
				Ts: common.UnixToTimestampPb(int64(ts * 1000)),
			},
		}
	}

	return nil
}
func (c *AxieroninConnector) LanditemLogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	landitemAbi, err := abi.JSON(strings.NewReader(landitem.LanditemABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Landitem ABI")
	}

	ev, err := landitemAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "AdminChanged":
		event := new(landitem.LanditemAdminChanged)
		if err := ethclient.UnpackLog(landitemAbi, event, "AdminChanged", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_adminchanged"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.AdminChanged{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldAdmin: event.OldAdmin.Bytes(),
				NewAdmin: event.NewAdmin.Bytes(),
			},
		}
	case "AdminRemoved":
		event := new(landitem.LanditemAdminRemoved)
		if err := ethclient.UnpackLog(landitemAbi, event, "AdminRemoved", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_adminremoved"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.AdminRemoved{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldAdmin: event.OldAdmin.Bytes(),
			},
		}
	case "Approval":
		event := new(landitem.LanditemApproval)
		if err := ethclient.UnpackLog(landitemAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_approval"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.Approval{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:    event.Owner.Bytes(),
				Approved: event.Approved.Bytes(),
				TokenId:  event.TokenId.Bytes(),
			},
		}
	case "ApprovalForAll":
		event := new(landitem.LanditemApprovalForAll)
		if err := ethclient.UnpackLog(landitemAbi, event, "ApprovalForAll", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_approvalforall"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.ApprovalForAll{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:    event.Owner.Bytes(),
				Operator: event.Operator.Bytes(),
				Approved: event.Approved,
			},
		}
	case "MinterAdded":
		event := new(landitem.LanditemMinterAdded)
		if err := ethclient.UnpackLog(landitemAbi, event, "MinterAdded", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_minteradded"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.MinterAdded{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				Minter: event.Minter.Bytes(),
			},
		}
	case "MinterRemoved":
		event := new(landitem.LanditemMinterRemoved)
		if err := ethclient.UnpackLog(landitemAbi, event, "MinterRemoved", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_minterremoved"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.MinterRemoved{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				Minter: event.Minter.Bytes(),
			},
		}
	case "NonceUpdated":
		event := new(landitem.LanditemNonceUpdated)
		if err := ethclient.UnpackLog(landitemAbi, event, "NonceUpdated", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_nonceupdated"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.NonceUpdated{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				TokenId: event.TokenId.Bytes(),
				Nonce:   event.Nonce.Bytes(),
			},
		}
	case "Paused":
		event := new(landitem.LanditemPaused)
		if err := ethclient.UnpackLog(landitemAbi, event, "Paused", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_paused"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.Paused{
				Ts: common.UnixToTimestampPb(int64(ts * 1000)),
			},
		}
	case "SpenderUnwhitelisted":
		event := new(landitem.LanditemSpenderUnwhitelisted)
		if err := ethclient.UnpackLog(landitemAbi, event, "SpenderUnwhitelisted", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_spenderunwhitelisted"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.SpenderUnwhitelisted{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Spender: event.Spender.Bytes(),
			},
		}
	case "SpenderWhitelisted":
		event := new(landitem.LanditemSpenderWhitelisted)
		if err := ethclient.UnpackLog(landitemAbi, event, "SpenderWhitelisted", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_spenderwhitelisted"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.SpenderWhitelisted{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Spender: event.Spender.Bytes(),
			},
		}
	case "Transfer":
		event := new(landitem.LanditemTransfer)
		if err := ethclient.UnpackLog(landitemAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_transfer"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.Transfer{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				From:    event.From.Bytes(),
				To:      event.To.Bytes(),
				TokenId: event.TokenId.Bytes(),
			},
		}
	case "Unpaused":
		event := new(landitem.LanditemUnpaused)
		if err := ethclient.UnpackLog(landitemAbi, event, "Unpaused", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["landitem_unpaused"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &landitem.Unpaused{
				Ts: common.UnixToTimestampPb(int64(ts * 1000)),
			},
		}
	}

	return nil
}
func (c *AxieroninConnector) RoninwethLogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	roninwethAbi, err := abi.JSON(strings.NewReader(roninweth.RoninwethABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Roninweth ABI")
	}

	ev, err := roninwethAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "Approval":
		event := new(roninweth.RoninwethApproval)
		if err := ethclient.UnpackLog(roninwethAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["roninweth_approval"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &roninweth.Approval{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:   event.Owner.Bytes(),
				Spender: event.Spender.Bytes(),
				Value:   event.Value.Bytes(),
			},
		}
	case "MinterAdded":
		event := new(roninweth.RoninwethMinterAdded)
		if err := ethclient.UnpackLog(roninwethAbi, event, "MinterAdded", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["roninweth_minteradded"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &roninweth.MinterAdded{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Account: event.Account.Bytes(),
			},
		}
	case "MinterRemoved":
		event := new(roninweth.RoninwethMinterRemoved)
		if err := ethclient.UnpackLog(roninwethAbi, event, "MinterRemoved", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["roninweth_minterremoved"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &roninweth.MinterRemoved{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Account: event.Account.Bytes(),
			},
		}
	case "Transfer":
		event := new(roninweth.RoninwethTransfer)
		if err := ethclient.UnpackLog(roninwethAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["roninweth_transfer"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &roninweth.Transfer{
				Ts:    common.UnixToTimestampPb(int64(ts * 1000)),
				From:  event.From.Bytes(),
				To:    event.To.Bytes(),
				Value: event.Value.Bytes(),
			},
		}
	}

	return nil
}
func (c *AxieroninConnector) SlpLogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	slpAbi, err := abi.JSON(strings.NewReader(slp.SlpABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Slp ABI")
	}

	ev, err := slpAbi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "AdminChanged":
		event := new(slp.SlpAdminChanged)
		if err := ethclient.UnpackLog(slpAbi, event, "AdminChanged", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["slp_adminchanged"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &slp.AdminChanged{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldAdmin: event.OldAdmin.Bytes(),
				NewAdmin: event.NewAdmin.Bytes(),
			},
		}
	case "AdminRemoved":
		event := new(slp.SlpAdminRemoved)
		if err := ethclient.UnpackLog(slpAbi, event, "AdminRemoved", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["slp_adminremoved"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &slp.AdminRemoved{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				OldAdmin: event.OldAdmin.Bytes(),
			},
		}
	case "Approval":
		event := new(slp.SlpApproval)
		if err := ethclient.UnpackLog(slpAbi, event, "Approval", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["slp_approval"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &slp.Approval{
				Ts:      common.UnixToTimestampPb(int64(ts * 1000)),
				Owner:   event.Owner.Bytes(),
				Spender: event.Spender.Bytes(),
				Value:   event.Value.Bytes(),
			},
		}
	case "MinterAdded":
		event := new(slp.SlpMinterAdded)
		if err := ethclient.UnpackLog(slpAbi, event, "MinterAdded", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["slp_minteradded"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &slp.MinterAdded{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				Minter: event.Minter.Bytes(),
			},
		}
	case "MinterRemoved":
		event := new(slp.SlpMinterRemoved)
		if err := ethclient.UnpackLog(slpAbi, event, "MinterRemoved", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["slp_minterremoved"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &slp.MinterRemoved{
				Ts:     common.UnixToTimestampPb(int64(ts * 1000)),
				Minter: event.Minter.Bytes(),
			},
		}
	case "Transfer":
		event := new(slp.SlpTransfer)
		if err := ethclient.UnpackLog(slpAbi, event, "Transfer", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["slp_transfer"],
			Key:   kafkautils.NewKey(Namespace, event.Raw.Address.Hex()),
			ProtoMsg: &slp.Transfer{
				Ts:    common.UnixToTimestampPb(int64(ts * 1000)),
				From:  event.From.Bytes(),
				To:    event.To.Bytes(),
				Value: event.Value.Bytes(),
			},
		}
	}

	return nil
}

// Backfill last 100 blocks
func (c *AxieroninConnector) backfill(out chan<- *kafkautils.Message, latestBlockNumber, backfillNumBlocks uint64, contract string, logToMsg func(ethtypes.Log) *kafkautils.Message) {
	filterQuery := geth.FilterQuery{
		FromBlock: big.NewInt(int64(latestBlockNumber - backfillNumBlocks)),
		ToBlock:   big.NewInt(int64(latestBlockNumber)),
		Addresses: c.addresses[contract],
	}

	logchan := make(chan ethtypes.Log)
	errchan := make(chan error)

	go c.ClientPool.ChunkedFilterLogs(context.Background(), filterQuery, 100, 1, logchan, errchan)

	maxWorkers := runtime.GOMAXPROCS(0)
	sem := semaphore.NewWeighted(int64(maxWorkers))

	for {
		select {
		case err := <-errchan:
			log.Error().Err(err).Msg("Failed to complete backfill")
		case evLog := <-logchan:
			if err := sem.Acquire(context.Background(), 1); err != nil {
				log.Error().Err(err).Msg("Failed to acquire semaaphor")
			}

			go func(evLog ethtypes.Log) {
				defer sem.Release(1)

				// Writes to out chan
				msg := logToMsg(evLog)
				if msg != nil {
					out <- msg
				}
			}(evLog)
		}
	}
}
