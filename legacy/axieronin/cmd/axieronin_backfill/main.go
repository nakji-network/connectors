// Code generated by connectorgen.
// go run ./connectors/source/axieronin/cmd/axieronin_backfill/main.go --fromBlock 11945500 --toBlock 11945502
package main

import (
	"context"
	"encoding/json"
	"math/big"
	"net/http"
	"net/url"
	"time"

	"blep.ai/data/chain/ethereum/ethclient"
	"blep.ai/data/config"
	"blep.ai/data/connectors/source/axieronin"
	"blep.ai/data/database"
	"github.com/nakji-network/connector/kafkautils"

	geth "github.com/ethereum/go-ethereum"
	ethcommon "github.com/ethereum/go-ethereum/common"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/rs/zerolog/log"
	"github.com/spf13/pflag"

	_ "net/http/pprof"
)

type Status struct {
	Step            int
	EventsProcessed map[string]uint64
	CurrentBlock    uint64
	Errors          []error
	FromBlock       int64
	ToBlock         int64
}

func main() {
	// Memory profiling
	go http.ListenAndServe(":6060", nil)

	// Load config in here to support flags
	pflag.Int64("fromBlock", 10000835, "backfill from this block")
	pflag.Int64("toBlock", 12000000, "backfill to this block")
	pflag.Int64("blockChunk", 3000, "get 100 blocks at a time to prevent timeouts")
	pflag.Int64P("maxConnections", "c", 10, "max simultaneous connections")
	pflag.Bool("upsert", true, "uses batch instead of COPY FROM when existing entries might exist")
	pflag.Int("dbBatch", 3000, "batch db writes by x items")
	pflag.Int64("processPairConcurrency", 4096, "max goroutines for pairProcessLog")

	var conf = config.InitConfig()

	conf.SetDefault("axieronin.axienftAddress", "0x32950db2a7164ae833121501c797d79e7b79d74c")
	conf.SetDefault("axieronin.axsAddress", "0x97a9107c1793bc407d6f527b77e7fff4d812bece")
	conf.SetDefault("axieronin.clockauctionAddress", "0x213073989821f738a7ba3520c3d31a1f9ad31bbd")
	conf.SetDefault("axieronin.landAddress", "0x8c811e3c958e190f5ec15fb376533a3398620500")
	conf.SetDefault("axieronin.landitemAddress", "0xa96660f0e4a3e9bc7388925d245a6d4d79e21259")
	conf.SetDefault("axieronin.roninwethAddress", "0xc99a6a985ed2cac1ef41640596c5a5f9f4e19ef5")
	conf.SetDefault("axieronin.slpAddress", "0xa8754b9fa15fc18bb59458815510e40a12cd2014")

	// get status of this long running status
	status := Status{
		FromBlock: conf.GetInt64("fromBlock"),
		ToBlock:   conf.GetInt64("toBlock"),
	}
	http.HandleFunc("/status", func(w http.ResponseWriter, req *http.Request) {
		js, err := json.Marshal(status)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(js)
	})
	go http.ListenAndServe(":8080", nil)

	// Load Topic registry
	kafkautils.TopicTypeRegistry.Load(axieronin.TopicTypes)

	rpcUrls := []string{(&url.URL{
		Scheme: conf.GetString("ethereum.archival.scheme"),
		User:   url.UserPassword(conf.GetString("ethereum.archival.username"), conf.GetString("ethereum.archival.password")),
		Host:   conf.GetString("ethereum.archival.host"),
		Path:   conf.GetString("ethereum.archival.path"),
	}).String(),
		(&url.URL{ // hacky to get past wss error
			Scheme: "wss",
			User:   url.UserPassword(conf.GetString("ethereum.archival.username"), conf.GetString("ethereum.archival.password")),
			Host:   conf.GetString("ethereum.archival.host"),
			Path:   conf.GetString("ethereum.archival.path"),
		}).String()}

	ethClientPool, err := ethclient.DialPoolContext(context.Background(), rpcUrls)
	if err != nil {
		log.Fatal().Err(err).Msg("Ethereum RPC connection error")
	}

	// Init historical db
	db, err := database.New(conf.GetString("timescaledb.connection"))
	if err != nil {
		log.Fatal().Err(err).Str("dsn", conf.GetString("timescaledb.connection")).Msg("Timescaledb connection failed")
	}
	defer db.Close()

	axienftAddress := ethcommon.HexToAddress(conf.GetString("axieronin.axienftAddress"))
	axsAddress := ethcommon.HexToAddress(conf.GetString("axieronin.axsAddress"))
	clockauctionAddress := ethcommon.HexToAddress(conf.GetString("axieronin.clockauctionAddress"))
	landAddress := ethcommon.HexToAddress(conf.GetString("axieronin.landAddress"))
	landitemAddress := ethcommon.HexToAddress(conf.GetString("axieronin.landitemAddress"))
	roninwethAddress := ethcommon.HexToAddress(conf.GetString("axieronin.roninwethAddress"))
	slpAddress := ethcommon.HexToAddress(conf.GetString("axieronin.slpAddress"))

	addresses := []ethcommon.Address{
		axienftAddress,
		axsAddress,
		clockauctionAddress,
		landAddress,
		landitemAddress,
		roninwethAddress,
		slpAddress,
	}

	query := geth.FilterQuery{
		Addresses: addresses,
		FromBlock: big.NewInt(conf.GetInt64("fromBlock")),
		ToBlock:   big.NewInt(conf.GetInt64("toBlock")),
	}

	client, err := ethClientPool.RandClient(true)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to find available client")
	}

	logsChan, _ := client.ChunkedFilterLogs(query, 0, conf.GetInt64("blockChunk"), conf.GetInt64("maxConnections"))

	start := time.Now()

	topics := map[string]kafkautils.Topic{
		"axienft_approval":                   kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.axienft_approval"), conf.GetString("kafka.env")),
		"axienft_approvalforall":             kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.axienft_approvalforall"), conf.GetString("kafka.env")),
		"axienft_axieevolved":                kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.axienft_axieevolved"), conf.GetString("kafka.env")),
		"axienft_axierebirthed":              kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.axienft_axierebirthed"), conf.GetString("kafka.env")),
		"axienft_axieretired":                kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.axienft_axieretired"), conf.GetString("kafka.env")),
		"axienft_axiespawned":                kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.axienft_axiespawned"), conf.GetString("kafka.env")),
		"axienft_transfer":                   kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.axienft_transfer"), conf.GetString("kafka.env")),
		"axs_approval":                       kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.axs_approval"), conf.GetString("kafka.env")),
		"axs_transfer":                       kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.axs_transfer"), conf.GetString("kafka.env")),
		"clockauction_adminchanged":          kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.clockauction_adminchanged"), conf.GetString("kafka.env")),
		"clockauction_adminremoved":          kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.clockauction_adminremoved"), conf.GetString("kafka.env")),
		"clockauction_auctioncancelled":      kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.clockauction_auctioncancelled"), conf.GetString("kafka.env")),
		"clockauction_auctioncreated":        kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.clockauction_auctioncreated"), conf.GetString("kafka.env")),
		"clockauction_auctionsuccessful":     kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.clockauction_auctionsuccessful"), conf.GetString("kafka.env")),
		"clockauction_paused":                kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.clockauction_paused"), conf.GetString("kafka.env")),
		"clockauction_tokenauctioncancelled": kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.clockauction_tokenauctioncancelled"), conf.GetString("kafka.env")),
		"clockauction_unpaused":              kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.clockauction_unpaused"), conf.GetString("kafka.env")),
		"land_adminchanged":                  kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_adminchanged"), conf.GetString("kafka.env")),
		"land_adminremoved":                  kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_adminremoved"), conf.GetString("kafka.env")),
		"land_approval":                      kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_approval"), conf.GetString("kafka.env")),
		"land_approvalforall":                kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_approvalforall"), conf.GetString("kafka.env")),
		"land_minteradded":                   kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_minteradded"), conf.GetString("kafka.env")),
		"land_minterremoved":                 kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_minterremoved"), conf.GetString("kafka.env")),
		"land_nonceupdated":                  kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_nonceupdated"), conf.GetString("kafka.env")),
		"land_paused":                        kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_paused"), conf.GetString("kafka.env")),
		"land_spenderunwhitelisted":          kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_spenderunwhitelisted"), conf.GetString("kafka.env")),
		"land_spenderwhitelisted":            kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_spenderwhitelisted"), conf.GetString("kafka.env")),
		"land_transfer":                      kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_transfer"), conf.GetString("kafka.env")),
		"land_unpaused":                      kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.land_unpaused"), conf.GetString("kafka.env")),
		"landitem_adminchanged":              kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_adminchanged"), conf.GetString("kafka.env")),
		"landitem_adminremoved":              kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_adminremoved"), conf.GetString("kafka.env")),
		"landitem_approval":                  kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_approval"), conf.GetString("kafka.env")),
		"landitem_approvalforall":            kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_approvalforall"), conf.GetString("kafka.env")),
		"landitem_minteradded":               kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_minteradded"), conf.GetString("kafka.env")),
		"landitem_minterremoved":             kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_minterremoved"), conf.GetString("kafka.env")),
		"landitem_nonceupdated":              kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_nonceupdated"), conf.GetString("kafka.env")),
		"landitem_paused":                    kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_paused"), conf.GetString("kafka.env")),
		"landitem_spenderunwhitelisted":      kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_spenderunwhitelisted"), conf.GetString("kafka.env")),
		"landitem_spenderwhitelisted":        kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_spenderwhitelisted"), conf.GetString("kafka.env")),
		"landitem_transfer":                  kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_transfer"), conf.GetString("kafka.env")),
		"landitem_unpaused":                  kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.landitem_unpaused"), conf.GetString("kafka.env")),
		"roninweth_approval":                 kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.roninweth_approval"), conf.GetString("kafka.env")),
		"roninweth_minteradded":              kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.roninweth_minteradded"), conf.GetString("kafka.env")),
		"roninweth_minterremoved":            kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.roninweth_minterremoved"), conf.GetString("kafka.env")),
		"roninweth_transfer":                 kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.roninweth_transfer"), conf.GetString("kafka.env")),
		"slp_adminchanged":                   kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.slp_adminchanged"), conf.GetString("kafka.env")),
		"slp_adminremoved":                   kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.slp_adminremoved"), conf.GetString("kafka.env")),
		"slp_approval":                       kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.slp_approval"), conf.GetString("kafka.env")),
		"slp_minteradded":                    kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.slp_minteradded"), conf.GetString("kafka.env")),
		"slp_minterremoved":                  kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.slp_minterremoved"), conf.GetString("kafka.env")),
		"slp_transfer":                       kafkautils.MustParseTopic(conf.GetString("axieronin.kafka.topic.slp_transfer"), conf.GetString("kafka.env")),
	}

	connector := axieronin.AxieroninConnector{
		Topics: topics,
	}

	// database write buffer
	buffer := make([]*kafkautils.Message, 0, conf.GetInt("dbBatch"))

	logToMessage := map[string]func(ethtypes.Log) *kafkautils.Message{
		conf.GetString("axieronin.axienftAddress"):      connector.AxienftLogToMsg,
		conf.GetString("axieronin.axsAddress"):          connector.AxsLogToMsg,
		conf.GetString("axieronin.clockauctionAddress"): connector.ClockauctionLogToMsg,
		conf.GetString("axieronin.landAddress"):         connector.LandLogToMsg,
		conf.GetString("axieronin.landitemAddress"):     connector.LanditemLogToMsg,
		conf.GetString("axieronin.roninwethAddress"):    connector.RoninwethLogToMsg,
		conf.GetString("axieronin.slpAddress"):          connector.SlpLogToMsg,
	}

	for evLog := range logsChan {
		status.CurrentBlock = evLog.BlockNumber
		msg := logToMessage[evLog.Address.Hex()](evLog)
		status.EventsProcessed[msg.Topic.Schema()]++

		buffer = append(buffer, msg)

		// Flush to db
		if len(buffer) == conf.GetInt("dbBatch") {
			if conf.GetBool("upsert") {
				errs := db.InsertBatchKafkaMessages(buffer)
				for _, err := range errs {
					log.Error().Err(err).
						Msg("InsertBatchKafkaMessages error")
					status.Errors = append(status.Errors, err)
				}
			} else {
				err = db.CopyFromKafkaMessages(context.Background(), "nakji.common.0_0_0.liquiditypool_change", buffer)
				if err != nil {
					log.Error().Err(err).
						Msg("CopyFromKafkaMessages error")
					status.Errors = append(status.Errors, err)
				}
			}

			log.Info().
				Dur("time", time.Since(start)).
				Interface("lastmsg", msg).
				//Interface("status", status).
				Msg("axieronin backfill in progress")

			buffer = nil
		}
	}

	// Flush remaining buffer
	if conf.GetBool("upsert") {
		errs := db.InsertBatchKafkaMessages(buffer)
		for _, err := range errs {
			log.Error().Err(err).
				Msg("InsertBatchKafkaMessages error")
			status.Errors = append(status.Errors, err)
		}
	} else {
		err = db.CopyFromKafkaMessages(context.Background(), "nakji.common.0_0_0.liquiditypool_change", buffer)
		if err != nil {
			log.Error().Err(err).
				Msg("CopyFromKafkaMessages error")
			status.Errors = append(status.Errors, err)
		}
	}

	log.Info().
		Dur("totaltime", time.Since(start)).
		Interface("status", &status).
		Msg("axieronin backfill completed")
}
