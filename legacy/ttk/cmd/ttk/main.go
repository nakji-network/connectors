// Code generated by connectorgen - Edit as necessary.

package main

import (
	"context"
	"net/http"

	"blep.ai/data/chain/ethereum/ethclient"
	"blep.ai/data/config"
	"blep.ai/data/connectors/source/ttk"
	"blep.ai/data/monitor"
	"github.com/nakji-network/connector/kafkautils"

	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/heptiolabs/healthcheck"
	"github.com/rs/zerolog/log"
)

var conf = config.InitConfig()

func init() {
	kafkautils.TopicTypeRegistry.Load(ttk.TopicTypes)
	conf.SetDefault("ttk.kafka.topic.ttk_approval", ".fct.nakji.ttk.0_0_0.ttk_approval")
	conf.SetDefault("ttk.kafka.topic.ttk_transfer", ".fct.nakji.ttk.0_0_0.ttk_transfer")

	conf.SetDefault("ttk.kafka.txID", "ttk")

	conf.SetDefault("ttk.ttkAddress", "0x39703A67bAC0E39f9244d97f4c842D15Fbad9C1f")
}

func main() {
	kp, err := kafkautils.NewProducer(conf.GetString("kafka.url"), conf.GetString("ttk.kafka.txID"))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to create new kafka producer")
	}

	urls := conf.GetStringSlice("bsc.rpc")

	log.Info().Strs("url", urls).Msg("connecting to Binance Smart Chain RPC")
	ethClientPool, err := ethclient.DialPoolContext(context.Background(), urls)
	if err != nil {
		log.Fatal().Err(err).Msg("Binance Smart Chain RPC connection error")
	}

	// For Liveness and Readiness Probe checks
	health := healthcheck.NewHandler()
	go http.ListenAndServe("0.0.0.0:8080", health)
	log.Info().Str("addr", "0.0.0.0:8080").Msg("healthcheck listening on /live and /ready")
	ttkAddress := ethcommon.HexToAddress(conf.GetString("ttk.ttkAddress"))

	addresses := map[string][]ethcommon.Address{
		"ttk": {ttkAddress},
	}

	topics := map[string]kafkautils.Topic{
		"ttk_approval": kafkautils.MustParseTopic(conf.GetString("ttk.kafka.topic.ttk_approval"), conf.GetString("kafka.env")),
		"ttk_transfer": kafkautils.MustParseTopic(conf.GetString("ttk.kafka.topic.ttk_transfer"), conf.GetString("kafka.env")),
	}

	connector := ttk.NewConnector(
		kp,
		addresses,
		topics,
		ethClientPool,
	)

	monitor.StartMonitor("ttk")
	connector.Start(context.Background(), conf.GetUint64("ttk.backfillNumBlocks"))
}
