// Code generated by connectorgen - Edit as necessary.
package opensea

import (
	"context"
	"fmt"
	"math/big"
	"runtime"
	"strings"
	"sync"

	"blep.ai/data/chain/ethereum/ethclient"
	"blep.ai/data/common"
	"blep.ai/data/connectors/source/opensea/wyvernexchangev1"
	"blep.ai/data/connectors/source/opensea/wyvernexchangev2"
	"github.com/nakji-network/connector/kafkautils"

	geth "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	ethcommon "github.com/ethereum/go-ethereum/common"
	ethtypes "github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/rs/zerolog/log"
	"golang.org/x/sync/semaphore"
)

const (
	Namespace      = "opensea"
	TokenNamespace = "ethereum"
)

type OpenseaConnector struct {
	KP         kafkautils.ProducerInterface
	Topics     map[string]kafkautils.Topic
	ClientPool ethclient.ETHClientPool
	addresses  map[string][]ethcommon.Address
	blockCache map[uint64]uint64
}

func NewConnector(
	kp kafkautils.ProducerInterface,
	addresses map[string][]ethcommon.Address,
	topics map[string]kafkautils.Topic,
	ethClientPool ethclient.ETHClientPool,

) *OpenseaConnector {
	var blockCache map[uint64]uint64

	return &OpenseaConnector{
		KP:         kp,
		Topics:     topics,
		ClientPool: ethClientPool,
		addresses:  addresses,
		blockCache: blockCache,
	}
}

func (c *OpenseaConnector) Start(ctx context.Context, backfillNumBlocks uint64) {
	// Mainly serves as Keepalive for websocket connection to RPC endpoint by subscribing to new heads
	unsubscribe := make(chan interface{})
	headers := c.ClientPool.ConsumeHeaders(unsubscribe)
	wyvernexchangev1Logs, sub0 := c.startListener(ctx, "wyvernexchangev1")
	wyvernexchangev2Logs, sub1 := c.startListener(ctx, "wyvernexchangev2")

	sink := make(chan *kafkautils.Message, 10000)
	errorSubs := []<-chan error{sub0.Err(), sub1.Err()}
	out := common.MergeErrChans(errorSubs...)

	err := c.KP.EnableTransactions()
	if err != nil {
		log.Fatal().Err(err).Msg("Transaction was not enabled")
	}
	go c.KP.WriteAndCommitSink(sink)

	var once sync.Once
	for {
		select {
		case <-ctx.Done():
			log.Info().Msg("worker cancelled and shutting down")
			return
		case header := <-headers:
			log.Debug().
				Str("block", header.Number.String()).
				Uint64("ts", header.Time).
				Msg("header received")

			ethclient.CacheBlockTimestamp(header.Hash(), header.Time)
		case err = <-out:
			log.Fatal().Err(err).Msg("Event listener failed")
			return
		case evLog := <-wyvernexchangev1Logs:
			if evLog.Removed {
				continue
			}

			go once.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "wyvernexchangev1", c.Wyvernexchangev1LogToMsg)
			})

			msg := c.Wyvernexchangev1LogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		case evLog := <-wyvernexchangev2Logs:
			if evLog.Removed {
				continue
			}

			go once.Do(func() {
				c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "wyvernexchangev2", c.Wyvernexchangev2LogToMsg)
			})

			msg := c.Wyvernexchangev2LogToMsg(evLog)

			if msg != nil {
				sink <- msg
			}
		}
	}
}

func (c *OpenseaConnector) startListener(ctx context.Context, contractName string) (chan ethtypes.Log, event.Subscription) {
	query := geth.FilterQuery{
		Addresses: c.addresses[contractName],
	}
	eventLogs := make(chan ethtypes.Log)
	sub, err := c.ClientPool.SubscribeFilterLogs(ctx, query, eventLogs)
	if err != nil {
		msg := fmt.Sprintf("%s contract listener failed", contractName)
		log.Fatal().Err(err).
			Interface("query", query).
			Msg(msg)
	}
	msg := fmt.Sprintf("%s contract listener live", contractName)
	log.Info().Interface("query", query).Msg(msg)

	return eventLogs, sub
}

func (c *OpenseaConnector) Wyvernexchangev1LogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	wyvernexchangev1Abi, err := abi.JSON(strings.NewReader(wyvernexchangev1.Wyvernexchangev1ABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Wyvernexchangev1 ABI")
	}

	ev, err := wyvernexchangev1Abi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "OrderApprovedPartOne":
		event := new(wyvernexchangev1.Wyvernexchangev1OrderApprovedPartOne)
		if err := ethclient.UnpackLog(wyvernexchangev1Abi, event, "OrderApprovedPartOne", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev1_orderapprovedpartone"],
			Key:   kafkautils.NewKey(Namespace, "OrderApprovedPartOne"),
			ProtoMsg: &wyvernexchangev1.OrderApprovedPartOne{
				Ts:               common.UnixToTimestampPb(int64(ts * 1000)),
				Hash:             event.Hash[:],
				Exchange:         event.Exchange.Bytes(),
				Maker:            event.Maker.Bytes(),
				Taker:            event.Taker.Bytes(),
				MakerRelayerFee:  event.MakerRelayerFee.Bytes(),
				TakerRelayerFee:  event.TakerRelayerFee.Bytes(),
				MakerProtocolFee: event.MakerProtocolFee.Bytes(),
				TakerProtocolFee: event.TakerProtocolFee.Bytes(),
				FeeRecipient:     event.FeeRecipient.Bytes(),
				FeeMethod:        uint32(event.FeeMethod),
				Side:             uint32(event.Side),
				SaleKind:         uint32(event.SaleKind),
				Target:           event.Target.Bytes(),
			},
		}
	case "OrderApprovedPartTwo":
		event := new(wyvernexchangev1.Wyvernexchangev1OrderApprovedPartTwo)
		if err := ethclient.UnpackLog(wyvernexchangev1Abi, event, "OrderApprovedPartTwo", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev1_orderapprovedparttwo"],
			Key:   kafkautils.NewKey(Namespace, "OrderApprovedPartTwo"),
			ProtoMsg: &wyvernexchangev1.OrderApprovedPartTwo{
				Ts:                        common.UnixToTimestampPb(int64(ts * 1000)),
				Hash:                      event.Hash[:],
				HowToCall:                 uint32(event.HowToCall),
				Calldata:                  event.Calldata,
				ReplacementPattern:        event.ReplacementPattern,
				StaticTarget:              event.StaticTarget.Bytes(),
				StaticExtradata:           event.StaticExtradata,
				PaymentToken:              event.PaymentToken.Bytes(),
				BasePrice:                 event.BasePrice.Bytes(),
				Extra:                     event.Extra.Bytes(),
				ListingTime:               event.ListingTime.Bytes(),
				ExpirationTime:            event.ExpirationTime.Bytes(),
				Salt:                      event.Salt.Bytes(),
				OrderbookInclusionDesired: event.OrderbookInclusionDesired,
			},
		}
	case "OrderCancelled":
		event := new(wyvernexchangev1.Wyvernexchangev1OrderCancelled)
		if err := ethclient.UnpackLog(wyvernexchangev1Abi, event, "OrderCancelled", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev1_ordercancelled"],
			Key:   kafkautils.NewKey(Namespace, "OrderCancelled"),
			ProtoMsg: &wyvernexchangev1.OrderCancelled{
				Ts:   common.UnixToTimestampPb(int64(ts * 1000)),
				Hash: event.Hash[:],
			},
		}
	case "OrdersMatched":
		event := new(wyvernexchangev1.Wyvernexchangev1OrdersMatched)
		if err := ethclient.UnpackLog(wyvernexchangev1Abi, event, "OrdersMatched", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev1_ordersmatched"],
			Key:   kafkautils.NewKey(Namespace, "OrdersMatched"),
			ProtoMsg: &wyvernexchangev1.OrdersMatched{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				BuyHash:  event.BuyHash[:],
				SellHash: event.SellHash[:],
				Maker:    event.Maker.Bytes(),
				Taker:    event.Taker.Bytes(),
				Price:    event.Price.Bytes(),
				Metadata: event.Metadata[:],
			},
		}
	case "OwnershipRenounced":
		event := new(wyvernexchangev1.Wyvernexchangev1OwnershipRenounced)
		if err := ethclient.UnpackLog(wyvernexchangev1Abi, event, "OwnershipRenounced", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev1_ownershiprenounced"],
			Key:   kafkautils.NewKey(Namespace, "OwnershipRenounced"),
			ProtoMsg: &wyvernexchangev1.OwnershipRenounced{
				Ts:            common.UnixToTimestampPb(int64(ts * 1000)),
				PreviousOwner: event.PreviousOwner.Bytes(),
			},
		}
	case "OwnershipTransferred":
		event := new(wyvernexchangev1.Wyvernexchangev1OwnershipTransferred)
		if err := ethclient.UnpackLog(wyvernexchangev1Abi, event, "OwnershipTransferred", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev1_ownershiptransferred"],
			Key:   kafkautils.NewKey(Namespace, "OwnershipTransferred"),
			ProtoMsg: &wyvernexchangev1.OwnershipTransferred{
				Ts:            common.UnixToTimestampPb(int64(ts * 1000)),
				PreviousOwner: event.PreviousOwner.Bytes(),
				NewOwner:      event.NewOwner.Bytes(),
			},
		}
	}

	return nil
}
func (c *OpenseaConnector) Wyvernexchangev2LogToMsg(evLog ethtypes.Log) *kafkautils.Message {
	ts, err := c.ClientPool.GetLogTimestamp(evLog, c.blockCache)
	if err != nil {
		log.Error().Err(err).
			Interface("blockNumber", evLog.BlockNumber).
			Msg("GetLogTimetsamp error")
	}

	wyvernexchangev2Abi, err := abi.JSON(strings.NewReader(wyvernexchangev2.Wyvernexchangev2ABI))
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to read Wyvernexchangev2 ABI")
	}

	ev, err := wyvernexchangev2Abi.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	switch ev.Name {
	case "NonceIncremented":
		event := new(wyvernexchangev2.Wyvernexchangev2NonceIncremented)
		if err := ethclient.UnpackLog(wyvernexchangev2Abi, event, "NonceIncremented", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev2_nonceincremented"],
			Key:   kafkautils.NewKey(Namespace, "NonceIncremented"),
			ProtoMsg: &wyvernexchangev2.NonceIncremented{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				Maker:    event.Maker.Bytes(),
				NewNonce: event.NewNonce.Bytes(),
			},
		}
	case "OrderApprovedPartOne":
		event := new(wyvernexchangev2.Wyvernexchangev2OrderApprovedPartOne)
		if err := ethclient.UnpackLog(wyvernexchangev2Abi, event, "OrderApprovedPartOne", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev2_orderapprovedpartone"],
			Key:   kafkautils.NewKey(Namespace, "OrderApprovedPartOne"),
			ProtoMsg: &wyvernexchangev2.OrderApprovedPartOne{
				Ts:               common.UnixToTimestampPb(int64(ts * 1000)),
				Hash:             event.Hash[:],
				Exchange:         event.Exchange.Bytes(),
				Maker:            event.Maker.Bytes(),
				Taker:            event.Taker.Bytes(),
				MakerRelayerFee:  event.MakerRelayerFee.Bytes(),
				TakerRelayerFee:  event.TakerRelayerFee.Bytes(),
				MakerProtocolFee: event.MakerProtocolFee.Bytes(),
				TakerProtocolFee: event.TakerProtocolFee.Bytes(),
				FeeRecipient:     event.FeeRecipient.Bytes(),
				FeeMethod:        uint32(event.FeeMethod),
				Side:             uint32(event.Side),
				SaleKind:         uint32(event.SaleKind),
				Target:           event.Target.Bytes(),
			},
		}
	case "OrderApprovedPartTwo":
		event := new(wyvernexchangev2.Wyvernexchangev2OrderApprovedPartTwo)
		if err := ethclient.UnpackLog(wyvernexchangev2Abi, event, "OrderApprovedPartTwo", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev2_orderapprovedparttwo"],
			Key:   kafkautils.NewKey(Namespace, "OrderApprovedPartTwo"),
			ProtoMsg: &wyvernexchangev2.OrderApprovedPartTwo{
				Ts:                        common.UnixToTimestampPb(int64(ts * 1000)),
				Hash:                      event.Hash[:],
				HowToCall:                 uint32(event.HowToCall),
				Calldata:                  event.Calldata,
				ReplacementPattern:        event.ReplacementPattern,
				StaticTarget:              event.StaticTarget.Bytes(),
				StaticExtradata:           event.StaticExtradata,
				PaymentToken:              event.PaymentToken.Bytes(),
				BasePrice:                 event.BasePrice.Bytes(),
				Extra:                     event.Extra.Bytes(),
				ListingTime:               event.ListingTime.Bytes(),
				ExpirationTime:            event.ExpirationTime.Bytes(),
				Salt:                      event.Salt.Bytes(),
				OrderbookInclusionDesired: event.OrderbookInclusionDesired,
			},
		}
	case "OrderCancelled":
		event := new(wyvernexchangev2.Wyvernexchangev2OrderCancelled)
		if err := ethclient.UnpackLog(wyvernexchangev2Abi, event, "OrderCancelled", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev2_ordercancelled"],
			Key:   kafkautils.NewKey(Namespace, "OrderCancelled"),
			ProtoMsg: &wyvernexchangev2.OrderCancelled{
				Ts:   common.UnixToTimestampPb(int64(ts * 1000)),
				Hash: event.Hash[:],
			},
		}
	case "OrdersMatched":
		event := new(wyvernexchangev2.Wyvernexchangev2OrdersMatched)
		if err := ethclient.UnpackLog(wyvernexchangev2Abi, event, "OrdersMatched", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev2_ordersmatched"],
			Key:   kafkautils.NewKey(Namespace, "OrdersMatched"),
			ProtoMsg: &wyvernexchangev2.OrdersMatched{
				Ts:       common.UnixToTimestampPb(int64(ts * 1000)),
				BuyHash:  event.BuyHash[:],
				SellHash: event.SellHash[:],
				Maker:    event.Maker.Bytes(),
				Taker:    event.Taker.Bytes(),
				Price:    event.Price.Bytes(),
				Metadata: event.Metadata[:],
			},
		}
	case "OwnershipRenounced":
		event := new(wyvernexchangev2.Wyvernexchangev2OwnershipRenounced)
		if err := ethclient.UnpackLog(wyvernexchangev2Abi, event, "OwnershipRenounced", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev2_ownershiprenounced"],
			Key:   kafkautils.NewKey(Namespace, "OwnershipRenounced"),
			ProtoMsg: &wyvernexchangev2.OwnershipRenounced{
				Ts:            common.UnixToTimestampPb(int64(ts * 1000)),
				PreviousOwner: event.PreviousOwner.Bytes(),
			},
		}
	case "OwnershipTransferred":
		event := new(wyvernexchangev2.Wyvernexchangev2OwnershipTransferred)
		if err := ethclient.UnpackLog(wyvernexchangev2Abi, event, "OwnershipTransferred", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return &kafkautils.Message{
			Topic: c.Topics["wyvernexchangev2_ownershiptransferred"],
			Key:   kafkautils.NewKey(Namespace, "OwnershipTransferred"),
			ProtoMsg: &wyvernexchangev2.OwnershipTransferred{
				Ts:            common.UnixToTimestampPb(int64(ts * 1000)),
				PreviousOwner: event.PreviousOwner.Bytes(),
				NewOwner:      event.NewOwner.Bytes(),
			},
		}
	}

	return nil
}

// Backfill last 100 blocks
func (c *OpenseaConnector) backfill(out chan<- *kafkautils.Message, latestBlockNumber, backfillNumBlocks uint64, contract string, logToMsg func(ethtypes.Log) *kafkautils.Message) {
	filterQuery := geth.FilterQuery{
		FromBlock: big.NewInt(int64(latestBlockNumber - backfillNumBlocks)),
		ToBlock:   big.NewInt(int64(latestBlockNumber)),
		Addresses: c.addresses[contract],
	}

	logchan := make(chan ethtypes.Log)
	errchan := make(chan error)

	go c.ClientPool.ChunkedFilterLogs(context.Background(), filterQuery, 100, 1, logchan, errchan)

	maxWorkers := runtime.GOMAXPROCS(0)
	sem := semaphore.NewWeighted(int64(maxWorkers))

	for {
		select {
		case err := <-errchan:
			log.Error().Err(err).Msg("Failed to complete backfill")
		case evLog := <-logchan:
			if err := sem.Acquire(context.Background(), 1); err != nil {
				log.Error().Err(err).Msg("Failed to acquire semaaphor")
			}

			go func(evLog ethtypes.Log) {
				defer sem.Release(1)

				// Writes to out chan
				msg := logToMsg(evLog)
				if msg != nil {
					out <- msg
				}
			}(evLog)
		}
	}
}
