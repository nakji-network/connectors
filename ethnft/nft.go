// Code generated by connectorgen - Edit as necessary.
package ethnft

import (
	"context"
	"fmt"
	"time"

	"github.com/alitto/pond"
	geth "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/ethereum/go-ethereum/event"

	"github.com/nakji-network/connector"
	nakjicommon "github.com/nakji-network/connector/common"
	"github.com/nakji-network/connectors/ethnft/erc1155"
	"github.com/nakji-network/connectors/ethnft/erc721"
	"github.com/rs/zerolog/log"
)

const (
	// It's not meaningful to have a namespace for ethnft
	Namespace      = ""
	TokenNamespace = "ethereum"
	network        = "ethereum"
)

//{ "startBlock": 5806610, "module": "erc721"  },
//{ "startBlock": 6930510, "module": "erc1155" }

type Connector struct {
	*connector.Connector
	Client *ethclient.Client
	sub    connector.ISubscription
}

func NewConnector(c *connector.Connector) *Connector {
	return &Connector{
		Connector: c,
	}
}

func (c *Connector) setup() {
	ctx := context.Background()

	sub, err := connector.NewSubscription(ctx, c.Connector, network, nil, 0, 0)
	c.sub = sub
	if err != nil {
		log.Fatal().Err(err).Msg(fmt.Sprintf("%s connection error", network))
	}
	c.Client = c.Connector.ChainClients.Ethereum(context.Background())
}

func (c *Connector) Start(ctx context.Context) { //, backfillNumBlocks uint64) {
	c.setup()

	erc721Abi, err := erc721.ERC721MetaData.GetAbi()
	if err != nil {
		log.Fatal().Err(err).Msg("Unable to get ABI")
	}

	erc1155Abi, err := erc1155.IERC1155MetaData.GetAbi()
	if err != nil {
		log.Fatal().Err(err).Msg("Unable to get ABI")
	}

	// Core listeners

	//Approval eventsig="event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)"
	//ApprovalForAll eventsig="event ApprovalForAll(address indexed owner, address indexed operator, bool approved)"
	//Transfer eventsig="event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"

	//ApprovalForAll eventsig="event ApprovalForAll(address indexed account, address indexed operator, bool approved)"
	//TransferBatch eventsig="event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values)"
	//TransferSingle eventsig="event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value)"
	//URI eventsig="event URI(string value, uint256 indexed id)"

	erc721EventNames := []string{
		"Approval",
		"ApprovalForAll",
		"Transfer",
	}
	erc1155EventNames := []string{
		"ApprovalForAll",
		"TransferBatch",
		"TransferSingle",
		"URI",
	}

	erc1155Logs, sub0 := c.startListener(ctx, erc1155Abi, erc1155EventNames)
	erc721Logs, sub1 := c.startListener(ctx, erc721Abi, erc721EventNames)

	// To address subscription queue overflow errors, we use the buffered queue in the worker pool.
	// We immediately consume messages in the subscription channel and place them in the worker
	// pool queue. Otherwise, when we receive a burst of notifications from our geth rpc node, we
	// will get a subscription queue overflow error.
	go c.consumeLogs(erc1155Logs, erc1155Abi, c.Erc1155LogToMsg)
	go c.consumeLogs(erc721Logs, erc721Abi, c.Erc721LogToMsg)

	for {
		select {
		case <-ctx.Done():
			log.Info().Msg("worker cancelled and shutting down")
			return
		case err = <-sub0.Err():
			log.Error().Err(err).Msg("ERC1155 listener failed")
			return
		case err = <-sub1.Err():
			log.Error().Err(err).Msg("ERC721 listener failed")
			return
		}
	}
}

func (c *Connector) consumeLogs(logs <-chan types.Log, contractAbi *abi.ABI, processLog func(evLog types.Log, a *abi.ABI) error) {
	// We want only 1 worker since we want to process each log synchronously. Processing them concurrently will fail because
	// we are using a transactional producer. Worker Pool here is used only for its buffer.
	pool := pond.New(1, 300_000)

	//var once sync.Once
	for evLog := range logs {
		pool.Submit(func() {
			if evLog.Removed {
				return
			}

			//go once.Do(func() {
			//c.backfill(sink, evLog.BlockNumber, backfillNumBlocks, "erc1155", c.Erc1155LogToMsg)
			//})

			if err := processLog(evLog, contractAbi); err != nil {
				log.Error().
					Err(err).
					Interface("log", evLog).
					Msg("failed to produce and commit message")
			}
		})
	}
}

func (c *Connector) startListener(ctx context.Context, abi *abi.ABI, eventNames []string) (chan types.Log, event.Subscription) {
	events := make([]common.Hash, len(eventNames))
	for i, name := range eventNames {
		ev, ok := abi.Events[name]
		if !ok {
			log.Fatal().
				Str("event", name).
				Msg("Invalid field")
		}
		log.Info().Str("eventsig", ev.String()).Msg("")
		events[i] = ev.ID
	}

	query := geth.FilterQuery{
		Topics: [][]common.Hash{events},
	}
	eventLogs := make(chan types.Log)
	sub, err := c.Client.SubscribeFilterLogs(ctx, query, eventLogs)
	if err != nil {
		log.Fatal().Err(err).
			Interface("query", query).
			Msg("contract listener failed")
	}
	log.Info().
		Interface("query", query).
		Msg("contract listener live")

	return eventLogs, sub
}

func (c *Connector) getTimestamp(vLog types.Log) uint64 {
	tWait := time.Second
	tMin := time.Second
	tMax := time.Second * 16

	ts, err := c.sub.GetBlockTime(context.Background(), vLog)
	for err != nil {
		log.Debug().Uint64("block", vLog.BlockNumber).Str("network", network).Msg("waiting for block timestamp")
		time.Sleep(tWait)
		tWait *= 2
		ts, err = c.sub.GetBlockTime(context.Background(), vLog)
		if err == nil {
			break
		}
		if tWait > tMax {
			log.Warn().Uint64("block", vLog.BlockNumber).Str("network", network).Msg("block timestamp not available")
			return uint64(time.Now().Unix())
		}
	}
	tWait = tMin

	return ts
}

func (c *Connector) Erc1155LogToMsg(evLog types.Log, a *abi.ABI) error {
	//ts, err := c.Client.GetLogTimestamp(evLog, c.blockCache)
	//if err != nil {
	//log.Error().Err(err).
	//Interface("blockNumber", evLog.BlockNumber).
	//Msg("GetLogTimetsamp error")
	//}

	ev, err := a.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	boundContract := bind.NewBoundContract(evLog.Address, *a, nil, nil, nil)

	// Make sure the number of indexed fields are what we expect
	if len(ev.Inputs)+1 != len(evLog.Topics) {
		return nil
	}

	ts := c.getTimestamp(evLog)

	switch ev.Name {
	case "ApprovalForAll":
		event := new(erc1155.IERC1155ApprovalForAll)
		if err := boundContract.UnpackLog(event, "ApprovalForAll", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc1155.ApprovalForAll{
			Ts:       nakjicommon.UnixToTimestampPb(int64(ts * 1000)),
			Account:  event.Account.Bytes(),
			Operator: event.Operator.Bytes(),
			Approved: event.Approved,
		})
	case "TransferBatch":
		event := new(erc1155.IERC1155TransferBatch)
		if err := boundContract.UnpackLog(event, "TransferBatch", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc1155.TransferBatch{
			Ts:       nakjicommon.UnixToTimestampPb(int64(ts * 1000)),
			Operator: event.Operator.Bytes(),
			From:     event.From.Bytes(),
			To:       event.To.Bytes(),
			Ids:      nakjicommon.DecodeBigIntArray(event.Ids),
			Values:   nakjicommon.DecodeBigIntArray(event.Values),
		})
	case "TransferSingle":
		event := new(erc1155.IERC1155TransferSingle)
		if err := boundContract.UnpackLog(event, "TransferSingle", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc1155.TransferSingle{
			Ts:       nakjicommon.UnixToTimestampPb(int64(ts * 1000)),
			Operator: event.Operator.Bytes(),
			From:     event.From.Bytes(),
			To:       event.To.Bytes(),
			Id:       event.Id.Bytes(),
			Value:    event.Value.Bytes(),
		})
	case "URI":
		event := new(erc1155.IERC1155URI)
		if err := boundContract.UnpackLog(event, "URI", evLog); err != nil {
			log.Error().Err(err).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc1155.URI{
			Ts:    nakjicommon.UnixToTimestampPb(int64(ts * 1000)),
			Value: event.Value,
			Id:    event.Id.Bytes(),
		})
	}

	return nil
}

func (c *Connector) Erc721LogToMsg(evLog types.Log, a *abi.ABI) error {
	//ts, err := c.Client.GetLogTimestamp(evLog, c.blockCache)
	//if err != nil {
	//log.Error().Err(err).
	//Interface("blockNumber", evLog.BlockNumber).
	//Msg("GetLogTimetsamp error")
	//}

	ev, err := a.EventByID(evLog.Topics[0])
	if err != nil {
		log.Fatal().Err(err).Msg("Failed to find event")
	}

	if ev == nil {
		return nil
	}

	boundContract := bind.NewBoundContract(evLog.Address, *a, nil, nil, nil)

	// Make sure the number of indexed fields are what we expect
	if len(ev.Inputs)+1 != len(evLog.Topics) {
		return nil
	}

	ts := c.getTimestamp(evLog)

	switch ev.Name {
	case "Approval":
		event := new(erc721.IERC721Approval)
		if err := boundContract.UnpackLog(event, "Approval", evLog); err != nil {
			log.Error().Err(err).Str("tx", evLog.TxHash.Hex()).Msg("Unpack event error")
			return nil
		}

		// TODO: subject should be contract address? or contract_tokenid
		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc721.Approval{
			Ts:       nakjicommon.UnixToTimestampPb(int64(ts * 1000)),
			Owner:    event.Owner.Bytes(),
			Approved: event.Approved.Bytes(),
			TokenId:  event.TokenId.Bytes(),
		})

	case "ApprovalForAll":
		event := new(erc721.IERC721ApprovalForAll)
		if err := boundContract.UnpackLog(event, "ApprovalForAll", evLog); err != nil {
			log.Error().Err(err).Str("tx", evLog.TxHash.Hex()).Msg("Unpack event error")
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc721.ApprovalForAll{
			Ts:       nakjicommon.UnixToTimestampPb(int64(ts * 1000)),
			Owner:    event.Owner.Bytes(),
			Operator: event.Operator.Bytes(),
			Approved: event.Approved,
		})

	case "Transfer":
		event := new(erc721.IERC721Transfer)

		if err := boundContract.UnpackLog(event, "Transfer", evLog); err != nil {
			return nil
		}

		return c.Connector.ProduceAndCommitMessage(Namespace, evLog.Address.Hex(), &erc721.Transfer{
			Ts:      nakjicommon.UnixToTimestampPb(int64(ts * 1000)),
			From:    event.From.Bytes(),
			To:      event.To.Bytes(),
			TokenId: event.TokenId.Bytes(),
		})

	}

	return nil
}

/*
// Backfill last 100 blocks
func (c *Connector) backfill(out chan<- *kafkautils.Message, latestBlockNumber, backfillNumBlocks uint64, contract string, logToMsg func(types.Log) *kafkautils.Message) {
	filterQuery := geth.FilterQuery{
		FromBlock: big.NewInt(int64(latestBlockNumber - backfillNumBlocks)),
		ToBlock:   big.NewInt(int64(latestBlockNumber)),
		Addresses: c.addresses[contract],
	}

	logchan := make(chan types.Log)
	errchan := make(chan error)

	go c.Client.ChunkedFilterLogs(context.Background(), filterQuery, 100, 1, logchan, errchan)

	maxWorkers := runtime.GOMAXPROCS(0)
	sem := semaphore.NewWeighted(int64(maxWorkers))

	for {
		select {
		case err := <-errchan:
			log.Error().Err(err).Msg("Failed to complete backfill")
		case evLog := <-logchan:
			if err := sem.Acquire(context.Background(), 1); err != nil {
				log.Error().Err(err).Msg("Failed to acquire semaaphor")
			}

			go func(evLog types.Log) {
				defer sem.Release(1)

				// Writes to out chan
				msg := logToMsg(evLog)
				if msg != nil {
					out <- msg
				}
			}(evLog)
		}
	}
}
*/
